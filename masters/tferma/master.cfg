# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory (although the filename
# can be changed with the --basedir option to 'mktap buildbot master').

# It has one job: define a dictionary named BuildmasterConfig. This
# dictionary has a variety of keys to control different aspects of the
# buildmaster. They are documented in docs/config.xhtml .


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# the 'slaves' list defines the set of allowable buildslaves. Each element is
# a BuildSlave object, which is created with bot-name, bot-password.  These
# correspond to values given to the buildslave's mktap invocation.
from buildbot.buildslave import BuildSlave
from buildbot.buildslave.libvirt import LibVirtSlave, Connection
c['slaves'] = []
c['slaves'].append(BuildSlave('sreabhan', 'tekcub', \
                              max_builds=4, properties={'os':'mint','arch':'64bit'}))
c['slaves'].append(LibVirtSlave('centos5.10_64bit', 'tekcub', Connection( 'qemu:///system' ), \
                                '/kvm/centos5.10_64bit/centos5.10_64bit.qcow2', \
                                max_builds=1, build_wait_timeout=60, properties={'os':'centos','arch':'64bit'}))
c['slaves'].append(LibVirtSlave('centos6.2_64bit', 'tekcub', Connection( 'qemu:///system' ), \
                                '/kvm/centos6.2_64bit/centos6.2_64bit.qcow2', \
                                max_builds=1, build_wait_timeout=60, properties={'os':'centos','arch':'64bit'}))
c['slaves'].append(LibVirtSlave('centos6.5_64bit', 'tekcub', Connection( 'qemu:///system' ), \
                                '/kvm/centos6.5_64bit/centos6.5_64bit.qcow2', \
                                max_builds=1, build_wait_timeout=60, properties={'os':'centos','arch':'64bit'}))
c['slaves'].append(LibVirtSlave('ubuntu12.04_64bit', 'tekcub', Connection( 'qemu:///system' ), \
                                '/kvm/ubuntu12.04_64bit/ubuntu12.04_64bit.qcow2', \
                                max_builds=1, build_wait_timeout=60, properties={'os':'ubuntu','arch':'64bit'}))
c['slaves'].append(LibVirtSlave('ubuntu12.04_32bit', 'tekcub', Connection( 'qemu:///system' ), \
                                '/kvm/ubuntu12.04_32bit/ubuntu12.04_32bit.qcow2', \
                                max_builds=1, build_wait_timeout=60, properties={'os':'ubuntu','arch':'32bit'}))
c['slaves'].append(LibVirtSlave('ubuntu14.04_64bit', 'tekcub', Connection( 'qemu:///system' ), \
                                '/kvm/ubuntu14.04_64bit/ubuntu14.04_64bit.qcow2', \
                                max_builds=1, build_wait_timeout=60, properties={'os':'ubuntu','arch':'64bit'}))

# to limit to two concurrent builds on a slave, use
#  c['slaves'] = [BuildSlave("bot1name", "bot1passwd", max_builds=2)]


# 'slavePortnum' defines the TCP port to listen on. This must match the value
# configured into the buildslaves (with their --master option)

c['slavePortnum'] = 9989

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes. Any class which implements IChangeSource can be
# put here: there are several in buildbot/changes/*.py to choose from.

#from buildbot.changes.pb import PBChangeSource
#c['change_source'] = PBChangeSource()
from buildbot.changes.gitpoller import GitPoller
c['change_source'] = []
c['change_source'].append(GitPoller('git@bitbucket.org:tferma/tferma.git',
                                    branches=['master','dolfin-master'],
                                    project='tferma_tferma',
                                    pollinterval=2*60,
                                    usetimestamps=False,
                                    workdir='gitpoller_workdir/tferma/tferma'))

# For example, if you had CVSToys installed on your repository, and your
# CVSROOT/freshcfg file had an entry like this:
#pb = ConfigurationSet([
#    (None, None, None, PBService(userpass=('foo', 'bar'), port=4519)),
#    ])

# then you could use the following buildmaster Change Source to subscribe to
# the FreshCVS daemon and be notified on every commit:
#
#from buildbot.changes.freshcvs import FreshCVSSource
#fc_source = FreshCVSSource("cvs.example.com", 4519, "foo", "bar")
#c['change_source'] = fc_source

# or, use a PBChangeSource, and then have your repository's commit script run
# 'buildbot sendchange', or use contrib/svn_buildbot.py, or
# contrib/arch_buildbot.py :
#
#from buildbot.changes.pb import PBChangeSource
#c['change_source'] = PBChangeSource()

# If you wat to use SVNPoller, it might look something like
#  # Where to get source code changes
# from buildbot.changes.svnpoller import SVNPoller
# source_code_svn_url='https://svn.myproject.org/bluejay/trunk'
# svn_poller = SVNPoller(
#                    svnurl=source_code_svn_url,
#                    pollinterval=60*60, # seconds
#                    histmax=10,
#                    svnbin='/usr/bin/svn',
## )
# c['sources'] = [ svn_poller ]

####### SCHEDULERS

## configure the Schedulers

from buildbot.changes.filter import ChangeFilter
from buildbot.schedulers.timed import Nightly
from buildbot.schedulers.triggerable import Triggerable
from buildbot.schedulers.forcesched import ForceScheduler
from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.steps.trigger import Trigger
c['schedulers'] = []
#schedulers configures below definition of builders...

####### BUILDERS

# the 'builders' list defines the Builders. Each one is configured with a
# dictionary, using the following keys:
#  name (required): the name used to describe this builder
#  slavename (required): which slave to use (must appear in c['bots'])
#  builddir (required): which subdirectory to run the builder in
#  factory (required): a BuildFactory to define how the build is run
#  periodicBuildTime (optional): if set, force a build every N seconds

# buildbot/process/factory.py provides several BuildFactory classes you can
# start with, which implement build processes for common targets (GNU
# autoconf projects, CPAN perl modules, etc). The factory.BuildFactory is the
# base class, and is configured with a series of BuildSteps. When the build
# is run, the appropriate buildslave is told to execute each Step in turn.

# the first BuildStep is typically responsible for obtaining a copy of the
# sources. There are source-obtaining Steps in buildbot/steps/source.py for
# CVS, SVN, and others.

from buildbot.steps.source import Git, Bzr
from buildbot.process import factory
from buildbot.config import BuilderConfig
from buildbot.steps.shell import ShellCommand, SetPropertyFromCommand
from buildbot.process.properties import Property, Properties, Interpolate
import buildbot.process.properties as properties
from buildbot.steps.python_twisted import Trial
from buildbot.interfaces import IRenderable
from zope.interface import implements
from collections import OrderedDict
import functools, os, copy

#############################################################################################################
def join_envs(*args):
  keys = set().union(*args)
  # list(OrderedDict.fromkeys()) removes duplicates
  # inner reversed ensures that the lowest path is kept
  # outer reverse makes most recent additions first (i.e. prepends path)
  return {k: ':'.join(reversed(list(OrderedDict.fromkeys(reversed([path for env in args for path in env.get(k,'').split(':') \
                                                                   if not path=='']))))) for k in keys}
#############################################################################################################

#############################################################################################################
def prepend_paths(env, workdir):
  for k, v in env.iteritems():
    if not k in ["PETSC_ARCH", "MPI_COMPILER", "MPI_SUFFIX"]:  # these do not get prepended
      env[k] = ':'.join([os.path.normpath(os.path.join(workdir, d)) if not os.path.isabs(d) else os.path.normpath(d) for d in v.split(':')])
  return env
#############################################################################################################

#############################################################################################################
@properties.renderer
def get_env(props):

  envs = []
  workdir = props['workdir']
  if props.hasProperty('tferma_env'): envs.append(props['tferma_env'])
  if props.hasProperty('fenics_env'): envs.append(props['fenics_env'])
  if props.hasProperty('petsc_env'): envs.append(prepend_paths(copy.copy(props['petsc_env']), workdir))
  if props.hasProperty('spud_env'):   envs.append(prepend_paths(copy.copy(props['spud_env']), workdir))
  if props.hasProperty('os') and props.hasProperty('arch'):
    if props['os']=='centos': envs.append(prepend_paths(get_centos_env(props['arch']), workdir))
  if props.hasProperty('base_env'):   envs.append(props['base_env'])
  env = join_envs(*envs)
  # 'BASH_ENV' is the environment variable used to load the config files,
  # it is automatically sourced at startup so we don't want it polluting our environment now
  # that we've been so careful to merge these environments together
  if 'BASH_ENV' in env: env.pop('BASH_ENV')
  return env
#############################################################################################################

#############################################################################################################
@properties.renderer
def get_dorsal_env(props):

  envs = []
  workdir = props['workdir']
  if props.hasProperty('dorsal_env'): envs.append(props['dorsal_env'])
  if props.hasProperty('os') and props.hasProperty('arch'):
    if props['os']=='centos': envs.append(prepend_paths(get_centos_env(props['arch']), workdir))
  if props.hasProperty('base_env'):   envs.append(props['base_env'])
  env = join_envs(*envs)
  # 'BASH_ENV' is the environment variable used to load the config files,
  # it is automatically sourced at startup so we don't want it polluting our environment now
  # that we've been so careful to merge these environments together
  if 'BASH_ENV' in env: env.pop('BASH_ENV')
  return env
#############################################################################################################

#############################################################################################################
@properties.renderer
def get_dolfin_build_env(props):
  '''DOLFIN needs a few extra hints when configuring that we don't want to use more generally.'''

  envs = []
  workdir = props['workdir']
  if props.hasProperty('fenics_conf_env'): envs.append(prepend_paths(copy.copy(props['fenics_conf_env']), workdir))
  if props.hasProperty('petsc_env'): envs.append(prepend_paths(copy.copy(props['petsc_env']), workdir))
  if props.hasProperty('os') and props.hasProperty('arch'):
    if props['os']=='centos': envs.append(prepend_paths(get_centos_env(props['arch']), workdir))
  if props.hasProperty('base_env'):   envs.append(props['base_env'])
  env = join_envs(*envs)
  # 'BASH_ENV' is the environment variable used to load the config files,
  # it is automatically sourced at startup so we don't want it polluting our environment now
  # that we've been so careful to merge these environments together
  if 'BASH_ENV' in env: env.pop('BASH_ENV')
  return env
#############################################################################################################

#############################################################################################################
def set_env_property(rc, stdout, stderr, env_name='env'):
    ''' Function used as the extract_fn function for SetPropertyFromCommand class
        This takes the output from env command and creates a dictionary of 
        the environment, the result of which is stored in a property names
        env'''
    if not rc:
        env_list = [ l.strip() for l in stdout.split('\n') ]
        env_dict={ l.split('=',1)[0]:l.split('=',1)[1] for l in 
                      env_list if len(l.split('=',1))==2}
        return {env_name:env_dict}
#############################################################################################################

#############################################################################################################
def get_base_env():
    
  env = {}
  env['LD_LIBRARY_PATH'] = ':'.join([ \
                         '/usr/local/lib',
                         '/usr/lib',
                         ])
  env['PATH'] = ':'.join([ \
                         '/bin',
                         '/usr/bin',
                         '/usr/local/bin',
                         '/home/buildbot/bin',
                         '/usr/local/games',
                         '/usr/games',
                         ])
  env['HOME'] = '/home/buildbot'

  return env
#############################################################################################################

#############################################################################################################
def get_spud_env(spudbuildername=None):
  '''Returns relative paths to the spud environment variables.'''
  '''Must be prepended with the spud-path when available in the builder.'''
    
  env = {}
  if spudbuildername is not None:
    env['PYTHONPATH']      = os.path.join(os.pardir, spudbuildername+'/install/lib/python2.7/site-packages')
    env['PATH']            = os.path.join(os.pardir, spudbuildername+'/install/bin')
    env['LD_LIBRARY_PATH'] = os.path.join(os.pardir, spudbuildername+'/install/lib')
    env['SPUD_DIR']        = os.path.join(os.pardir, spudbuildername+'/install')

  return env
#############################################################################################################

#############################################################################################################
def get_petsc_env(petscbuildername=None, petscversion=None, debug=False):
  '''If petscbuildername is provided this returns relative paths to the petsc environment variables.'''
  '''These Must be prepended with the spud-path when available in the builder.'''
  '''Otherwise an absolute path is returned.'''

  petsc_dir = "/PETSC_DIR_NOT_SET"
  petscarch = "/PETSC_ARCH_NOT_SET"
  if petscbuildername is not None:
    petsc_dir  = os.path.join(os.pardir, petscbuildername+"/build")
    petsc_arch = "petsc-arch"
  elif petscversion is not None:
    petsc_dir  = "/usr/local/tferma/petsc"
    petsc_arch = "maint-"+petscversion
    if debug:
      petsc_arch = petsc_arch+'-debug'
    else:
      petsc_arch = petsc_arch+'-opt'

  env = {}
  env['PETSC_DIR']        = petsc_dir
  env['PETSC_ARCH']       = petsc_arch
  env['PATH']             = petsc_dir+'/'+petsc_arch+'/bin'
  env['LD_LIBRARY_PATH']  = petsc_dir+'/'+petsc_arch+'/lib'
  env['PYTHONPATH']       = petsc_dir+'/'+petsc_arch+'/lib/python2.7/site-packages'
  env['METIS_LIBRARY']    = petsc_dir+"/"+petsc_arch+"/lib/libmetis.so"
  env['PARMETIS_LIBRARY'] = petsc_dir+"/"+petsc_arch+"/lib/libparmetis.so"

  return env
#############################################################################################################

#############################################################################################################
def get_fenics_conf_env(fenicsbuildername):
  '''Returns relative paths to fenics environment variables required to be hardcoded during configuration.'''
  
  env = {}
  env['PYTHONPATH']      = os.path.join(os.pardir, fenicsbuildername+'-dolfin/install/lib/python2.7/site-packages')
  env['PATH']            = os.path.join(os.pardir, fenicsbuildername+'-dolfin/install/bin')
  #env['LD_LIBRARY_PATH'] = os.path.join(os.pardir, fenicsbuildername+'-dolfin/install/lib')
  #env['PKG_CONFIG_PATH'] = os.path.join(os.pardir, fenicsbuildername+'-dolfin/install/lib/pkgconfig')

  return env
#############################################################################################################

#############################################################################################################
def get_centos_env(arch):
  '''Returns paths to environment variables required to be hardcoded during configuration in centos.'''
  
  if arch=='32bit':
    lib = 'lib'
    suffix = 'i386'
  else:
    lib = 'lib64'
    suffix = 'x86_64'

  env = {}
  env['PATH'] =            '/usr/'+lib+'/openmpi/bin'
  env['LD_LIBRARY_PATH'] = ':'.join([ \
                                     '/usr/'+lib+'/openmpi/lib', \
                                     '/usr/'+lib, \
                                     'install/lib/vtk-5.8', \
                                     # this will be converted relative to workdir later
                                     ])  
  env['PYTHONPATH'] =      '/usr/'+lib+'/python2.6/site-packages/openmpi'
  env['MPI_BIN'] =         '/usr/'+lib+'/openmpi/bin'
  env['MPI_SYSCONFIG'] =   '/etc/openmpi-'+suffix
  env['MPI_FORTRAN_MOD_DIR'] = '/usr/'+lib+'/gfortran/modules/openmpi-'+suffix
  env['MPI_INCLUDE'] =     '/usr/include/openmpi-'+suffix
  env['MPI_LIB'] =         '/usr/'+lib+'/openmpi/lib'
  env['MPI_MAN'] =         '/usr/share/man/openmpi-'+suffix
  env['MPI_PYTHON_SITEARCH'] = '/usr/'+lib+'/python2.6/site-packages/openmpi'
  env['MPI_COMPILER'] =    'openmpi-'+suffix
  env['MPI_SUFFIX'] =      '_openmpi'
  env['MPI_HOME'] =        '/usr/'+lib+'/openmpi'
  env['BOOST_LIBRARYDIR'] = '/usr/'+lib+'/openmpi/lib'

  return env
#############################################################################################################

#############################################################################################################
class GetConfDir(object):
    implements(IRenderable)

    def __init__(self, builderdir, confdir):
        self.builderdir = builderdir
        self.confdir    = confdir

    def getRenderingFor(self, props):
        '''Returns the path to the configuration directory for the builderdir and confdir given'''
        workdir = props['workdir']
        return os.path.normpath(os.path.join(workdir, os.pardir, self.builderdir, "install", "share", self.confdir))
#############################################################################################################

#############################################################################################################
class GetFenicsInstallDir(object):
    implements(IRenderable)

    def __init__(self, fenicsbuildername, prefix):
        self.fenicsbuildername = fenicsbuildername
        self.prefix=prefix

    def getRenderingFor(self, props):
        workdir = props['workdir']
        return self.prefix+os.path.normpath(os.path.join(workdir, os.pardir, self.fenicsbuildername+'-dolfin', "install"))
#############################################################################################################

#############################################################################################################
class GetPetscPath(object):
    implements(IRenderable)

    def __init__(self, prefix='', suffixes=[]):
        self.prefix=prefix
        self.suffixes=suffixes

    def getRenderingFor(self, props):
        '''Returns the absolute path to PETSC_DIR/PETSC_ARCH (with an optional prefix and suffixes)'''
        workdir    = props['workdir']
        petsc_env  = props['petsc_env']
        petsc_dir  = petsc_env["PETSC_DIR"]
        petsc_arch = petsc_env["PETSC_ARCH"]
        if os.path.isabs(petsc_dir):
          return self.prefix+os.path.normpath(os.path.join(*([petsc_dir, petsc_arch]+self.suffixes)))
        else:
          return self.prefix+os.path.normpath(os.path.join(*([workdir, os.pardir, petsc_dir, petsc_arch]+self.suffixes)))
#############################################################################################################

#############################################################################################################
from buildbot.status.builder import SUCCESS, WARNINGS, FAILURE, SKIPPED
class TFTestHarness(ShellCommand):
  def evaluateCommand(self, cmd):
    if cmd.rc != 0: return FAILURE
    self.warnOnWarnings = True
    passcount = -1
    failcount = -1
    counts = cmd.logs['stdio'].getText().strip().split('\n')[-19:]
    for count in counts:
      if count.strip().startswith("Passes:"):
        passcount = int(count.split()[-1])
      if count.strip().startswith("Failures:"):
        failcount = int(count.split()[-1])
        print "Line failing is: ", count

    # counts haven't been set (something went wrong above) or failcount is positive
    if failcount != 0 or passcount < 0: return FAILURE
    # passcount is positive and there were no failures
    if passcount > 0 and failcount==0: return SUCCESS
    # presumably passcount was 0?...
    return SKIPPED
#############################################################################################################

#############################################################################################################
def mk_tferma_builder(repo, slavename, tfermabuildername, 
                      fenicsbuildername, petscbuildername=None, petscversion=None, spudbuildername=None,
                      pretriggers=None, posttriggers=None, 
                      test=False, mediumtest=False, 
                      verbose=False, debug=False):

  verbosity = []
  if verbose: verbosity = ["VERBOSE=1"]

  if debug:
    build_type = 'Debug'
  else:
    build_type = 'RelWithDebInfo'

  configure_options = [
     "-DCMAKE_BUILD_TYPE="+build_type,
     Interpolate('-DCMAKE_INSTALL_PREFIX=%(prop:workdir)s/install'),
     ]

  cpack_options = [
     "-G", "DEB", 
     "-D", "CPACK_INSTALL_PREFIX=/tmp/install1", 
     "-D", "CPACK_INSTALL_CMAKE_PROJECTS=.;terraferma;ALL;/", 
     "-D", "CPACK_PACKAGE_FILE_NAME=terraferma-0.1-Linux", 
     "-D", "CPACK_PACKAGE_NAME=terraferma", 
     "-D", "CPACK_PACKAGE_DESCRIPTION=terraferma package", 
     "-D", "CPACK_PACKAGE_DESCRIPTION_SUMMARY=terraferma package", 
     "-D", "CPACK_PACKAGE_VERSION=0.1", 
     "-D", "CPACK_CMAKE_GENERATOR=Unix Makefiles", 
     "-D", "CPACK_PACKAGE_CONTACT=Cian Wilson <cwilson@ldeo.columbia.edu>", 
     "-D", "CPACK_SET_DESTDIR=ON"
     ]

  f = factory.BuildFactory()
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  if pretriggers is not None:
    f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  f.addStep(ShellCommand(command=["rm", "-rf", "install"], workdir=Property('workdir'), haltOnFailure=True, description="clean-install"))
  f.addStep(ShellCommand(command=["rm", "-rf", "build"], workdir="build", haltOnFailure=True, description="clean-build"))
  f.addStep(ShellCommand(command=["mkdir", "-p", "build"], workdir="build", haltOnFailure=True, description="setup"))
  f.addStep(SetPropertyFromCommand(command=["bash", "-c", "env"],
              extract_fn=functools.partial(set_env_property, env_name='fenics_env'),
              workdir=GetConfDir(fenicsbuildername+'-dolfin', 'dolfin'),
              env={'BASH_ENV':'dolfin.conf' }))
  f.addStep(ShellCommand(command=["cmake"]+configure_options+["../."], \
                         workdir="build/build", env=get_env, haltOnFailure=True, description="cmake"))
  f.addStep(ShellCommand(command=["make"]+verbosity, workdir="build/build", env=get_env, haltOnFailure=True, description="make"))
  f.addStep(ShellCommand(command=["make", "install"]+verbosity, workdir="build/build", env=get_env, haltOnFailure=True, description="install"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  if test or mediumtest:
    f.addStep(SetPropertyFromCommand(command=["bash", "-c", "env"],
                extract_fn=functools.partial(set_env_property, env_name='tferma_env'),
                workdir=GetConfDir(tfermabuildername, 'terraferma'),
                env={'BASH_ENV':'terraferma.conf' }))
  if test: 
    f.addStep(TFTestHarness(command=["make", "test"]+verbosity, workdir="build/build", env=get_env, haltOnFailure=True, description="test"))
  if mediumtest: 
    f.addStep(TFTestHarness(command=["make", "mediumtest"]+verbosity, workdir="build/build", env=get_env, haltOnFailure=True, description="mediumtest", timeout=10000))
  f.addStep(ShellCommand(command=["cpack"]+cpack_options, workdir="build/build", env=get_env, haltOnFailure=True, description="package"))
  
  base_env = get_base_env()
  spud_env = get_spud_env(spudbuildername=spudbuildername)
  petsc_env = get_petsc_env(petscbuildername=petscbuildername, \
                            petscversion=petscversion, \
                            debug=debug)

  b = BuilderConfig(name = tfermabuildername, slavename = slavename, builddir = tfermabuildername,
                    factory = f, category = "tferma", 
                    properties={'petsc_env': petsc_env, 'spud_env': spud_env, \
                                'base_env': base_env})

  return b
#############################################################################################################

#############################################################################################################
def mk_tferma_benchmarks_builder(repo, slavename, benchmarksbuildername, tfermabuildername, 
                                 fenicsbuildername, petscbuildername=None, petscversion=None, spudbuildername=None,
                                 pretriggers=None, posttriggers=None, debug=False):

  f = factory.BuildFactory()
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  if pretriggers is not None:
    f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  f.addStep(SetPropertyFromCommand(command=["bash", "-c", "env"],
              extract_fn=functools.partial(set_env_property, env_name='fenics_env'),
              workdir=GetConfDir(fenicsbuildername+'-dolfin', 'dolfin'),
              env={'BASH_ENV':'dolfin.conf' }))
  f.addStep(SetPropertyFromCommand(command=["bash", "-c", "env"],
              extract_fn=functools.partial(set_env_property, env_name='tferma_env'),
              workdir=GetConfDir(tfermabuildername, 'terraferma'),
              env={'BASH_ENV':'terraferma.conf' }))
  f.addStep(TFTestHarness(command=["tfsimulationharness", "--test", "-l", "short", "-r", "--", "*.shml"], 
                          workdir="build", env=get_env,haltOnFailure=True, description="test",timeout=None))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  
  base_env  = get_base_env()
  spud_env  = get_spud_env(spudbuildername=spudbuildername)
  petsc_env = get_petsc_env(petscbuildername=petscbuildername, \
                            petscversion=petscversion, \
                            debug=debug)

  b = BuilderConfig(name = benchmarksbuildername, slavename = slavename, builddir = benchmarksbuildername,
                    factory = f, category = "benchmarks",
                    properties={'petsc_env': petsc_env, 'spud_env': spud_env, \
                                'base_env': base_env})

  return b
#############################################################################################################

#############################################################################################################
def mk_dorsal_builder(repo, slavename, dorsalbuildername, project="TerraFERMA",
                             pretriggers=None, posttriggers=None, debug=False):

  base_env = get_base_env()

  command=Interpolate("echo \"# Meta-project to build\n"+\
                            "PROJECT=%(kw:project)s\n"+\
                            "# Where do you want the downloaded source files to go?\n"+\
                            "DOWNLOAD_PATH=%(prop:workdir)s/download\n"+\
                            "# Where do you want the compiled software installed?\n"+\
                            "INSTALL_PATH=%(prop:workdir)s/install\n"+\
                            "# How many processes would you like to build using?\n"+\
                            "PROCS=1\n"+\
                            "# For TerraFERMA the two following variables should be set to false\n"+\
                            "STABLE_BUILD=false\n"+\
                            "USE_SNAPSHOTS=false\n\" > local.cfg", project=project)


  f = factory.BuildFactory()
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  if pretriggers is not None:
    f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  f.addStep(ShellCommand(command=["rm", "-rf", "install"], workdir=Property('workdir'), haltOnFailure=True, description="clean-install"))
  f.addStep(ShellCommand(command=["rm", "-rf", "download"], workdir=Property('workdir'), haltOnFailure=True, description="clean-download"))
  # needs to be run as a shell command - not sure why...
  f.addStep(ShellCommand(command=command, 
                          workdir="build", env=base_env, haltOnFailure=True, description="setup"))
  f.addStep(ShellCommand(command=["./dorsal.sh"], 
                          workdir="build", env=get_dorsal_env, haltOnFailure=True, description="build"))
  if project=="TerraFERMA":
    f.addStep(SetPropertyFromCommand(command=["bash", "-c", "env"],
                extract_fn=functools.partial(set_env_property, env_name='dorsal_env'),
                workdir=GetConfDir(dorsalbuildername, 'dorsal'),
                env={'BASH_ENV':'dorsal-terraferma.conf' }))
    f.addStep(ShellCommand(command=["run_tftests"],
                workdir="build", env=get_dorsal_env, description="test"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  
  b = BuilderConfig(name = dorsalbuildername, slavename = slavename, builddir = dorsalbuildername,
                    factory = f, category = "dorsal", properties={'base_env':base_env})

  return b
#############################################################################################################

#############################################################################################################
def mk_petsc_builder(repo, slavename, petscbuildername, posttriggers=None, debug=False):

  # debug and petscversion are only necessary arguments when not using a petscbuilder...
  petsc_env = get_petsc_env(petscbuildername=petscbuildername) 
  petsc_arch = petsc_env["PETSC_ARCH"]

  env = get_base_env()

  configure_options = [
     Interpolate('--PETSC_DIR=%(prop:workdir)s/build'),
     '--PETSC_ARCH='+petsc_arch,
     '--with-clanguage=C++',
     '--with-shared-libraries=1',
     '--download-umfpack=1',
     '--download-hypre=1',
     '--download-ml=1',
     '--download-parmetis=1',
     '--download-metis=1',
     '--download-blacs=1',
     '--download-scalapack=1',
     '--download-mumps=1',
     ]

  if debug:
    configure_options += ['--with-debugging=1']
  else:
    configure_options += ['--with-debugging=0']

  f = factory.BuildFactory()
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  f.addStep(ShellCommand(command=["./configure"]+configure_options, workdir="build", haltOnFailure=True, description="configure"))
  f.addStep(ShellCommand(command=["make", Interpolate("PETSC_DIR=%(prop:workdir)s/build"), "PETSC_ARCH="+petsc_arch, "all"], workdir="build", haltOnFailure=True, description="build"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  f.addStep(ShellCommand(command=["make", Interpolate("PETSC_DIR=%(prop:workdir)s/build"), "PETSC_ARCH="+petsc_arch, "test"], workdir="build", haltOnFailure=True, description="test"))
  
  b = BuilderConfig(name = petscbuildername, slavename = slavename, builddir = petscbuildername,
                    factory = f, category = 'petsc')

  return b
#############################################################################################################

#############################################################################################################
def mk_fenics_ufc_builder(repo, slavename, fenicsbuildername, pretriggers=None, posttriggers=None, \
                          mergebranch=None, verbose=False, debug=False):

  env = get_base_env()

  verbosity = []
  if verbose: verbosity = ["VERBOSE=1"]

  if debug:
    build_type = 'Debug'
  else:
    build_type = 'RelWithDebInfo'

  directory = '/'.join([slavename, fenicsbuildername])

  f = factory.BuildFactory()
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  if mergebranch is not None:
    f.addStep(ShellCommand(command=["git", "fetch", mergebranch[0]+"/ufc.git", mergebranch[1]+":mergebranch/"+mergebranch[1]], 
                                    workdir="build", haltOnFailure=True, description="fetch"))
    f.addStep(ShellCommand(command=["git", "merge", "mergebranch/"+mergebranch[1]], workdir="build", haltOnFailure=True, description="merge"))
  if pretriggers is not None:
    f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  f.addStep(ShellCommand(command=["rm", "-rf", "build"], workdir="build", haltOnFailure=True, description="clean-build"))
  f.addStep(ShellCommand(command=["mkdir", "-p", "build"], workdir="build", haltOnFailure=True, description="setup"))
  f.addStep(ShellCommand(command=["cmake", "-DCMAKE_BUILD_TYPE="+build_type, \
                                  GetFenicsInstallDir(fenicsbuildername, "-DCMAKE_INSTALL_PREFIX="), \
                                  "../."], workdir="build/build", env=env, haltOnFailure=True, description="cmake"))
  f.addStep(ShellCommand(command=["make"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="make"))
  f.addStep(ShellCommand(command=["make", "install"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="install"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))

  b = BuilderConfig(name = fenicsbuildername+'-ufc', slavename = slavename, builddir = fenicsbuildername+'-ufc',
                    factory = f, category = 'ufc')

  return b
#############################################################################################################

#############################################################################################################
def mk_fenics_dolfin_builder(repo, slavename, fenicsbuildername, 
                             petscbuildername=None, petscversion=None, 
                             test=False, pretriggers=None, posttriggers=None, mergebranch=None,
                             verbose=False, debug=False):

  verbosity = []
  if verbose: verbosity = ["VERBOSE=1"]

  if debug:
    build_type = 'Debug'
  else:
    build_type = 'RelWithDebInfo'

  directory = '/'.join([slavename, fenicsbuildername])
  configure_options = [
     "-DCMAKE_BUILD_TYPE="+build_type, 
     GetFenicsInstallDir(fenicsbuildername, "-DCMAKE_INSTALL_PREFIX="), 
     "-DDOLFIN_ENABLE_TRILINOS:BOOL=OFF", 
     "-DDOLFIN_ENABLE_SLEPC:BOOL=OFF", 
     GetPetscPath(prefix="-DAMD_INCLUDE_DIRS=", suffixes=["include"]), 
     GetPetscPath(prefix="-DAMD_LIBRARIES=", suffixes=["lib", "libamd.a"]), 
     GetPetscPath(prefix="-METIS_LIBRARY=", suffixes=["lib", "libmetis.so"]), 
     GetPetscPath(prefix="-DPARMETIS_INCLUDE_DIRS=", suffixes=["include"]), 
     GetPetscPath(prefix="-DPARMETIS_LIBRARY=", suffixes=["lib", "libmetis.so"]), 
     GetPetscPath(prefix="-DUMFPACK_INCLUDE_DIRS=", suffixes=["include"]), 
     GetPetscPath(prefix="-DUMFPACK_LIBRARY=", suffixes=["lib", "libumfpack.a"]),
     "-DDOLFIN_ENABLE_CGAL:BOOL=OFF",
     "-DDOLFIN_ENABLE_TESTING:BOOL=ON",
     ]

  f = factory.BuildFactory()
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  f.addStep(ShellCommand(command=["rm", "-rf", "install"], workdir=Property('workdir'), haltOnFailure=True, description="clean-install"))
  if mergebranch is not None:
    f.addStep(ShellCommand(command=["git", "fetch", mergebranch[0]+"/dolfin.git", mergebranch[1]+":mergebranch/"+mergebranch[1]], 
                                    workdir="build", haltOnFailure=True, description="fetch"))
    f.addStep(ShellCommand(command=["git", "merge", "mergebranch/"+mergebranch[1]], workdir="build", haltOnFailure=True, description="merge"))
  if pretriggers is not None:
    f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  f.addStep(ShellCommand(command=["rm", "-rf", "build"], workdir="build", haltOnFailure=True, description="clean-build"))
  f.addStep(ShellCommand(command=["mkdir", "-p", "build"], workdir="build", haltOnFailure=True, description="setup"))
  f.addStep(ShellCommand(command=["cmake"]+configure_options+["../."], workdir="build/build", env=get_dolfin_build_env, haltOnFailure=True, description="cmake"))
  f.addStep(ShellCommand(command=["make"]+verbosity, workdir="build/build", env=get_dolfin_build_env, haltOnFailure=True, description="make"))
  f.addStep(ShellCommand(command=["make", "install"]+verbosity, workdir="build/build", env=get_dolfin_build_env, haltOnFailure=True, description="install"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  f.addStep(SetPropertyFromCommand(command=["bash", "-c", "env"],
              extract_fn=functools.partial(set_env_property, env_name='fenics_env'),
              workdir=GetConfDir(fenicsbuildername+'-dolfin', 'dolfin'),
              env={'BASH_ENV':'dolfin.conf' }))
  f.addStep(ShellCommand(command=["make", "test"]+verbosity, workdir="build/build", env=get_env, haltOnFailure=True, description="make test"))
  f.addStep(ShellCommand(command=["make", "demo"]+verbosity, workdir="build/build", env=get_env, haltOnFailure=True, description="make demo"))
  f.addStep(ShellCommand(command=["make", "bench"]+verbosity, workdir="build/build", env=get_env, haltOnFailure=True, description="make bench"))
  if test:
    f.addStep(ShellCommand(command=["make", "run_unittests"]+verbosity, workdir="build/build", env=get_env, haltOnFailure=False, description="make run_unittests"))
    f.addStep(ShellCommand(command=["make", "run_regressiontests"]+verbosity, workdir="build/build", env=get_env, haltOnFailure=False, description="make run_regressiontests"))
    f.addStep(ShellCommand(command=["make", "run_systemtests"]+verbosity, workdir="build/build", env=get_env, haltOnFailure=False, description="make run_systemtests"))

  base_env = get_base_env()
  fenics_conf_env = get_fenics_conf_env(fenicsbuildername)
  petsc_env = get_petsc_env(petscbuildername=petscbuildername, \
                            petscversion=petscversion, \
                            debug=debug)

  b = BuilderConfig(name = fenicsbuildername+'-dolfin', slavename = slavename, builddir = fenicsbuildername+'-dolfin',
                    factory = f, category = 'dolfin',
                    properties={'fenics_conf_env': fenics_conf_env, 'petsc_env': petsc_env, 'base_env': base_env})

  return b
#############################################################################################################

#############################################################################################################
def mk_fenics_python_builder(repo, slavename, fenicsbuildername, project, test=False, 
                             pretriggers=None, posttriggers=None,
                             mergebranch=None, debug=False):

  commands = ["python", "setup.py", "install", GetFenicsInstallDir(fenicsbuildername, "--prefix=")] 
  if debug: commands.append("-O0")

  f = factory.BuildFactory()
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  if mergebranch is not None:
    f.addStep(ShellCommand(command=["git", "fetch", mergebranch[0]+"/"+project+".git", mergebranch[1]+":mergebranch/"+mergebranch[1]], 
                                    workdir="build", haltOnFailure=True, description="fetch"))
    f.addStep(ShellCommand(command=["git", "merge", "mergebranch/"+mergebranch[1]], workdir="build", haltOnFailure=True, description="merge"))
  if pretriggers is not None:
    f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  f.addStep(ShellCommand(command=commands, workdir="build", env=get_env, haltOnFailure=True, description="install"))
  if test:
    f.addStep(SetPropertyFromCommand(command=["bash", "-c", "env"],
                extract_fn=functools.partial(set_env_property, env_name='fenics_env'),
                workdir=GetConfDir(fenicsbuildername+'-dolfin', 'dolfin'),
                env={'BASH_ENV':'dolfin.conf' }))
    f.addStep(ShellCommand(command=["python", "test.py"], workdir="build/test", env=get_env, haltOnFailure=True, description="test"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  
  base_env = get_base_env()

  b = BuilderConfig(name = fenicsbuildername+"-"+project, slavename = slavename, 
                    builddir = fenicsbuildername+"-"+project, factory = f,
                    category = project,
                    properties={'base_env': base_env})

  return b
#############################################################################################################

#############################################################################################################
def mk_fenics_instant_builder(repo, slavename, fenicsbuildername, test=False, 
                              pretriggers=None, posttriggers=None, mergebranch=None, debug=False):

  commands = ["python", "setup.py", "install", GetFenicsInstallDir(fenicsbuildername, "--prefix=")] 
  if debug: commands.append("-O0")

  f = factory.BuildFactory()
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  if mergebranch is not None:
    f.addStep(ShellCommand(command=["git", "fetch", mergebranch[0]+"/instant.git", mergebranch[1]+":mergebranch/"+mergebranch[1]], 
                                    workdir="build", haltOnFailure=True, description="fetch"))
    f.addStep(ShellCommand(command=["git", "merge", "mergebranch/"+mergebranch[1]], workdir="build", haltOnFailure=True, description="merge"))
  if pretriggers is not None:
    f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  f.addStep(ShellCommand(command=commands, workdir="build", env=get_env, haltOnFailure=True, description="install"))
  if test:
    f.addStep(SetPropertyFromCommand(command=["bash", "-c", "env"],
                extract_fn=functools.partial(set_env_property, env_name='fenics_env'),
                workdir=GetConfDir(fenicsbuildername+'-dolfin', 'dolfin'),
                env={'BASH_ENV':'dolfin.conf' }))
    f.addStep(ShellCommand(command=["python", "run_tests.py"], workdir="build/test", env=get_env, haltOnFailure=True, description="run_tests"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  
  base_env = get_base_env()

  b = BuilderConfig(name = fenicsbuildername+"-instant", slavename = slavename, builddir = fenicsbuildername+"-instant",
                    factory = f, category = 'instant',
                    properties={'base_env': base_env})

  return b
#############################################################################################################

#############################################################################################################
def mk_spud_builder(repourl, slavename, spudbuildername, debug=False):

  env = get_base_env()

  commands = ["./configure"]
  if debug: commands += ["--enable-debugging"]
  commands += [Interpolate("--prefix=%(prop:workdir)s/install")]

  f = factory.BuildFactory()
  f.addStep(Bzr(repourl=repourl, mode='clobber'))
  f.addStep(ShellCommand(command=["rm", "-rf", "install"], workdir=Property('workdir'), haltOnFailure=True, description="clean-install"))
  f.addStep(ShellCommand(command=commands, workdir="build", env=env, haltOnFailure=True, description="configure"))
  f.addStep(ShellCommand(command=["make"], workdir="build", env=env, haltOnFailure=True, description="make"))
  f.addStep(ShellCommand(command=["make", "install"], workdir="build", env=env, haltOnFailure=True, description="install"))

  b = BuilderConfig(name = spudbuildername, slavename = slavename, builddir = spudbuildername,
                    factory = f, category = "spud")

  return b
#############################################################################################################

#############################################################################################################
def mk_fenics_builders(repos, slavename, fenicsbuildername, test=False,
                       petscbuildername=None, petscversion=None, posttriggers=None, mergebranch=None,
                       verbose=False, debug=False):
   
  builders = []
  schedulers = []
  
  builders.append(mk_fenics_python_builder(repos['ufl'], slavename, fenicsbuildername, "ufl", test=test, 
                                           mergebranch=mergebranch, debug=debug))
  schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

  builders.append(mk_fenics_instant_builder(repos['instant'], slavename, fenicsbuildername, test=test,
                                           mergebranch=mergebranch, debug=debug))
  schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

  builders.append(mk_fenics_python_builder(repos['fiat'], slavename, fenicsbuildername, "fiat", test=test, 
                                           mergebranch=mergebranch, debug=debug))
  schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

  builders.append(mk_fenics_python_builder(repos['ffc'], slavename, fenicsbuildername, "ffc", test=test,
                                           mergebranch=mergebranch, debug=debug))
  schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

  builders.append(mk_fenics_ufc_builder(repos['ufc'], slavename, fenicsbuildername,
                                        verbose=verbose, mergebranch=mergebranch, debug=debug))
  schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

  dolfinbuilder = mk_fenics_dolfin_builder(repos['dolfin'], slavename, fenicsbuildername, petscbuildername=petscbuildername, \
                                           petscversion=petscversion, test=test, \
                                           pretriggers=[fenicsbuildername+'-'+p for p in ["ufl", "instant", "fiat", "ffc", "ufc"]] ,\
                                           posttriggers=posttriggers, \
                                           mergebranch=mergebranch, verbose=verbose, debug=debug)
  
  return dolfinbuilder, builders, schedulers
#############################################################################################################

builders = []
schedulers = []

# spud builder
builders.append(mk_spud_builder('lp:spud', 'sreabhan', 'SPuD-spud'))

# PETSc-tferma_petsc_maint builder
petscrepo = ['git@bitbucket.org:tferma/petsc.git', 'maint']
builders.append(mk_petsc_builder(petscrepo, 'sreabhan', 'PETSc-tferma_petsc_maint', debug=True))

# PETSc-petsc_petsc_maint builder
petscrepo = ['git@bitbucket.org:petsc/petsc.git', 'maint']
builders.append(mk_petsc_builder(petscrepo, 'sreabhan', 'PETSc-petsc_petsc_maint', debug=True))

# FEniCS-tferma_fenics_master builders
repos = {
          'ufl'     : ['git@bitbucket.org:tferma/ufl.git',     'master'],
          'instant' : ['git@bitbucket.org:tferma/instant.git', 'master'],
          'fiat'    : ['git@bitbucket.org:tferma/fiat.git',    'master'],
          'ffc'     : ['git@bitbucket.org:tferma/ffc.git',     'master'],
          'ufc'     : ['git@bitbucket.org:tferma/ufc.git',     'master'],
          'dolfin'  : ['git@bitbucket.org:tferma/dolfin.git',  'master'],
        }
dolfinbuilder, tmpbuilders, tmpschedulers = mk_fenics_builders(repos, 'sreabhan', 'FEniCS-tferma_fenics_master', 
                                                               petscbuildername='PETSc-petsc_petsc_maint', debug=True)
builders = builders + tmpbuilders
schedulers = schedulers + tmpschedulers
builders.append(dolfinbuilder)
#schedulers.append(Nightly(name=dolfinbuilder.name, branch=None, builderNames=[dolfinbuilder.name], hour=2))

# TerraFERMA-tferma_tferma_dolfinmaster builder
tfermarepo = ['git@bitbucket.org:tferma/tferma.git', 'dolfin-master']
builders.append(mk_tferma_builder(tfermarepo, 'sreabhan', 'TerraFERMA-tferma_tferma_dolfinmaster', 
                      'FEniCS-tferma_fenics_master', petscbuildername='PETSc-petsc_petsc_maint', spudbuildername='SPuD-spud',
                      test=True, mediumtest=False, debug=True, verbose=False))
schedulers.append(SingleBranchScheduler(
                  name = builders[-1].name,
                  builderNames = [builders[-1].name],
                  change_filter = ChangeFilter(
                          project = 'tferma_tferma',
                          branch  = 'dolfin-master'
                  )))

# PETSc-petsc_petsc_master builder
petscrepo = ['git@bitbucket.org:petsc/petsc.git', 'master']
builders.append(mk_petsc_builder(petscrepo, 'sreabhan', 'PETSc-petsc_petsc_master', 
                posttriggers=['FEniCS-fenics_fenics_master-dolfin'], debug=True))
schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], hour=2))

# fenics-project_fenics_master builder
repos = {
          'ufl'     : ['git@bitbucket.org:fenics-project/ufl.git',     'master'],
          'instant' : ['git@bitbucket.org:fenics-project/instant.git', 'master'],
          'fiat'    : ['git@bitbucket.org:fenics-project/fiat.git',    'master'],
          'ffc'     : ['git@bitbucket.org:fenics-project/ffc.git',     'master'],
          'ufc'     : ['git@bitbucket.org:fenics-project/ufc.git',     'master'],
          'dolfin'  : ['git@bitbucket.org:fenics-project/dolfin.git',  'master'],
        }
dolfinbuilder, tmpbuilders, tmpschedulers = mk_fenics_builders(repos, 'sreabhan', 'FEniCS-fenics_fenics_master', 
                                                               petscbuildername='PETSc-petsc_petsc_master', debug=True,
                                                               posttriggers=['TerraFERMA-tferma_tferma_dolfinmaster-testupdate'])
builders = builders + tmpbuilders
schedulers = schedulers + tmpschedulers
builders.append(dolfinbuilder)
schedulers.append(Triggerable(name=dolfinbuilder.name, builderNames=[dolfinbuilder.name]))


# TerraFERMA-tferma_tferma_dolfinmaster_test-update builder (built against nightly build of fenics_fenics_master)
tfermarepo = ['git@bitbucket.org:tferma/tferma.git', 'dolfin-master']
builders.append(mk_tferma_builder(tfermarepo, 'sreabhan', 'TerraFERMA-tferma_tferma_dolfinmaster-testupdate', 
                      'FEniCS-fenics_fenics_master', petscbuildername='PETSc-petsc_petsc_master', spudbuildername='SPuD-spud',
                      test=True, mediumtest=False, debug=True))
schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))


# PETSc-petsc_petsc_next builder
petscrepo = ['git@bitbucket.org:petsc/petsc.git', 'next']
builders.append(mk_petsc_builder(petscrepo, 'sreabhan', 'PETSc-petsc_petsc_next', 
                posttriggers=['FEniCS-fenics_fenics_next-dolfin'], debug=True))
schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], hour=2))

# fenics-project_fenics_next builder
repos = {
          'ufl'     : ['git@bitbucket.org:fenics-project/ufl.git',     'next'],
          'instant' : ['git@bitbucket.org:fenics-project/instant.git', 'next'],
          'fiat'    : ['git@bitbucket.org:fenics-project/fiat.git',    'next'],
          'ffc'     : ['git@bitbucket.org:fenics-project/ffc.git',     'next'],
          'ufc'     : ['git@bitbucket.org:fenics-project/ufc.git',     'next'],
          'dolfin'  : ['git@bitbucket.org:fenics-project/dolfin.git',  'next'],
        }
dolfinbuilder, tmpbuilders, tmpschedulers = mk_fenics_builders(repos, 'sreabhan', 'FEniCS-fenics_fenics_next', 
                                                               petscbuildername='PETSc-petsc_petsc_next', debug=True,
                                                               posttriggers=['TerraFERMA-tferma_tferma_dolfinmaster-testnextupdate'])
builders = builders + tmpbuilders
schedulers = schedulers + tmpschedulers
builders.append(dolfinbuilder)
schedulers.append(Triggerable(name=dolfinbuilder.name, builderNames=[dolfinbuilder.name]))


# TerraFERMA-tferma_tferma_dolfinmaster_testnextupdate builder (built against nightly build of fenics_fenics_nextupdate)
tfermarepo = ['git@bitbucket.org:tferma/tferma.git', 'dolfin-master']
builders.append(mk_tferma_builder(tfermarepo, 'sreabhan', 'TerraFERMA-tferma_tferma_dolfinmaster-testnextupdate', 
                      'FEniCS-fenics_fenics_next', petscbuildername='PETSc-petsc_petsc_next', spudbuildername='SPuD-spud',
                      test=True, mediumtest=False, debug=True))
schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))


# FEniCS-tferma_fenics_tferma-master builder
repos = {
          'ufl'     : ['git@bitbucket.org:tferma/ufl.git',     'tferma-master'],
          'instant' : ['git@bitbucket.org:tferma/instant.git', 'tferma-master'],
          'fiat'    : ['git@bitbucket.org:tferma/fiat.git',    'tferma-master'],
          'ffc'     : ['git@bitbucket.org:tferma/ffc.git',     'tferma-master'],
          'ufc'     : ['git@bitbucket.org:tferma/ufc.git',     'tferma-master'],
          'dolfin'  : ['git@bitbucket.org:tferma/dolfin.git',  'tferma-master'],
        }
dolfinbuilder, tmpbuilders, tmpschedulers = mk_fenics_builders(repos, 'sreabhan', 'FEniCS-tferma_fenics_tfermamaster', 
                                                               petscbuildername='PETSc-petsc_petsc_maint', debug=True)
builders = builders + tmpbuilders
schedulers = schedulers + tmpschedulers
builders.append(dolfinbuilder)

# TerraFERMA-tferma_tferma_master builder
tfermarepo = ['git@bitbucket.org:tferma/tferma.git', 'master']
builders.append(mk_tferma_builder(tfermarepo, 'sreabhan', 'TerraFERMA-tferma_tferma_master', 
                      'FEniCS-tferma_fenics_tfermamaster', petscbuildername='PETSc-petsc_petsc_maint', spudbuildername='SPuD-spud',
                      test=True, mediumtest=False, debug=True))
                      #test=True, mediumtest=False, debug=True, posttriggers=["Benchmarks-tferma_benchmarks_master"]))
schedulers.append(SingleBranchScheduler(
                  name = builders[-1].name,
                  builderNames = [builders[-1].name],
                  change_filter = ChangeFilter(
                          project = 'tferma_tferma',
                          branch  = 'master'
                  )))

# Benchmarks-tferma_benchmarks_master builder
benchmarksrepo = ['git@bitbucket.org:tferma/benchmarks.git', 'master']
builders.append(mk_tferma_benchmarks_builder(benchmarksrepo, 'sreabhan', 'Benchmarks-tferma_benchmarks_master',
                'TerraFERMA-tferma_tferma_master', 'FEniCS-tferma_fenics_tfermamaster', petscbuildername='PETSc-petsc_petsc_maint',
                spudbuildername='SPuD-spud', debug=True))
#schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

# FEniCS-tferma_fenics_tfermamaster_merge builder
repos = {
          'ufl'     : ['git@bitbucket.org:tferma/ufl.git',     'tferma-master'],
          'instant' : ['git@bitbucket.org:tferma/instant.git', 'tferma-master'],
          'fiat'    : ['git@bitbucket.org:tferma/fiat.git',    'tferma-master'],
          'ffc'     : ['git@bitbucket.org:tferma/ffc.git',     'tferma-master'],
          'ufc'     : ['git@bitbucket.org:tferma/ufc.git',     'tferma-master'],
          'dolfin'  : ['git@bitbucket.org:tferma/dolfin.git',  'tferma-master'],
        }
dolfinbuilder, tmpbuilders, tmpschedulers = mk_fenics_builders(repos, 'sreabhan', 'FEniCS-tferma_fenics_tfermamaster-merge', 
                                                               petscbuildername='PETSc-petsc_petsc_maint', 
                                                               mergebranch=['git@bitbucket.org:fenics-project', 'master'], 
                                                               debug=True, posttriggers=['TerraFERMA-tferma_tferma_master-testmerge'])
builders = builders + tmpbuilders
schedulers = schedulers + tmpschedulers
builders.append(dolfinbuilder)
schedulers.append(Nightly(name=dolfinbuilder.name, branch=None, builderNames=[dolfinbuilder.name], hour=2))


# TerraFERMA-tferma_tferma_master-testmerge builder
tfermarepo = ['git@bitbucket.org:tferma/tferma.git', 'master']
builders.append(mk_tferma_builder(tfermarepo, 'sreabhan', 'TerraFERMA-tferma_tferma_master-testmerge', 
                      'FEniCS-tferma_fenics_tfermamaster-merge', petscbuildername='PETSc-petsc_petsc_maint', spudbuildername='SPuD-spud',
                      test=True, mediumtest=False, debug=True))
                      #test=True, mediumtest=False, debug=True, posttriggers=['Benchmarks-tferma_benchmarks_master-testmerge']))
schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

# Benchmarks-tferma_benchmarks_master-testmerge builder
benchmarksrepo = ['git@bitbucket.org:tferma/benchmarks.git', 'master']
builders.append(mk_tferma_benchmarks_builder(benchmarksrepo, 'sreabhan', 'Benchmarks-tferma_benchmarks_master-testmerge',
                'TerraFERMA-tferma_tferma_master-testmerge', 'FEniCS-tferma_fenics_tfermamaster-merge', petscbuildername='PETSc-petsc_petsc_maint',
                spudbuildername='SPuD-spud', debug=True))
#schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

dorsalrepo = ['git@bitbucket.org:tferma/dorsal.git', 'tferma-master']
builders.append(mk_dorsal_builder(dorsalrepo, 'sreabhan', 'Dorsal-tferma_dorsal_tfermamaster'))
schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], dayOfWeek=7, hour=0))

dorsalrepo = ['git@bitbucket.org:tferma/dorsal.git', 'tferma-master']
builders.append(mk_dorsal_builder(dorsalrepo, 'centos5.10_64bit', 'Dorsal_FEniCS-tferma_dorsal_tfermamaster-centos5.10_64bit', project='FEniCS'))
#schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], dayOfWeek=3, hour=0))

dorsalrepo = ['git@bitbucket.org:tferma/dorsal.git', 'tferma-master']
builders.append(mk_dorsal_builder(dorsalrepo, 'centos6.2_64bit', 'Dorsal_FEniCS-tferma_dorsal_tfermamaster-centos6.2_64bit', project='FEniCS'))
#schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], dayOfWeek=3, hour=0))

dorsalrepo = ['git@bitbucket.org:tferma/dorsal.git', 'tferma-master']
builders.append(mk_dorsal_builder(dorsalrepo, 'centos6.5_64bit', 'Dorsal_FEniCS-tferma_dorsal_tfermamaster-centos6.5_64bit', project='FEniCS'))
#schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], dayOfWeek=4, hour=0))

dorsalrepo = ['git@bitbucket.org:tferma/dorsal.git', 'tferma-master']
builders.append(mk_dorsal_builder(dorsalrepo, 'centos6.2_64bit', 'Dorsal-tferma_dorsal_tfermamaster-centos6.2_64bit'))
schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], dayOfWeek=3, hour=0))

dorsalrepo = ['git@bitbucket.org:tferma/dorsal.git', 'tferma-master']
builders.append(mk_dorsal_builder(dorsalrepo, 'centos6.5_64bit', 'Dorsal-tferma_dorsal_tfermamaster-centos6.5_64bit'))
schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], dayOfWeek=4, hour=0))

dorsalrepo = ['git@bitbucket.org:tferma/dorsal.git', 'tferma-master']
builders.append(mk_dorsal_builder(dorsalrepo, 'ubuntu12.04_64bit', 'Dorsal-tferma_dorsal_tfermamaster-ubuntu12.04_64bit'))
schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], dayOfWeek=5, hour=0))

dorsalrepo = ['git@bitbucket.org:tferma/dorsal.git', 'tferma-master']
builders.append(mk_dorsal_builder(dorsalrepo, 'ubuntu12.04_32bit', 'Dorsal-tferma_dorsal_tfermamaster-ubuntu12.04_32bit'))
schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], dayOfWeek=6, hour=0))

dorsalrepo = ['git@bitbucket.org:tferma/dorsal.git', 'tferma-master']
builders.append(mk_dorsal_builder(dorsalrepo, 'ubuntu14.04_64bit', 'Dorsal-tferma_dorsal_tfermamaster-ubuntu14.04_64bit'))
#schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], dayOfWeek=5, hour=0))

# Add a force scheduler to every builder (for the web page "Force Build" button)
for builder in builders:
  name = builder.name + '-force'
  schedulers.append(ForceScheduler(name=name, builderNames=[builder.name]))

c['builders'] = builders
c['schedulers'] = schedulers

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

# Use allowForce=True (boolean, not a string. ie: not 'True') to allow
# Forcing Builds in the Web User Interface. The default is False.
# from buildbot.status import html
# c['status'].append(html.WebStatus(http_port=8010,allowForce=True))

from buildbot.status import html
from buildbot.status.web.authz import Authz
from buildbot.status.web.auth import BasicAuth
users = [('buildbot', 'tekcub')]
authz = Authz(auth=BasicAuth(users),
              forceBuild='auth',
              stopBuild='auth',
              stopAllBuilds='auth',
              cancelPendingBuild='auth'
             )
#authz = Authz(
#              forceBuild=True,
#              stopBuild=True,
#              stopAllBuilds=True,
#              cancelPendingBuild=True
#             )
c['status'].append(html.WebStatus(http_port=8010, authz=authz))

from buildbot.status import mail
c['status'].append(mail.MailNotifier(fromaddr="buildbot@sreabhan.ldeo.columbia.edu", mode="failing",
                                     extraRecipients=["cwilson@ldeo.columbia.edu", "mspieg@ldeo.columbia.edu"],
                                     sendToInterestedUsers=False))

# from buildbot.status import words
# c['status'].append(words.IRC(host="irc.example.com", nick="bb",
#                              channels=["#example"]))
#
# from buildbot.status import client
# c['status'].append(client.PBListener(9988))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually committing changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

#c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")


####### PROJECT IDENTITY

# the 'projectName' string will be used to describe the project that this
# buildbot is working on. For example, it is used as the title of the
# waterfall HTML page. The 'projectURL' string will be used to provide a link
# from buildbot HTML pages to your project's home page.

c['projectName'] = "TerraFERMA"
c['projectURL'] = "https://bitbucket.org/tferma/tferma"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.Waterfall page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://sreabhan.ldeo.columbia.edu:8010/waterfall"
