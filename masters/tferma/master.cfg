# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory (although the filename
# can be changed with the --basedir option to 'mktap buildbot master').

# It has one job: define a dictionary named BuildmasterConfig. This
# dictionary has a variety of keys to control different aspects of the
# buildmaster. They are documented in docs/config.xhtml .


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

####### BUILDSLAVES

# the 'slaves' list defines the set of allowable buildslaves. Each element is
# a BuildSlave object, which is created with bot-name, bot-password.  These
# correspond to values given to the buildslave's mktap invocation.
from buildbot.buildslave import BuildSlave
c['slaves'] = [BuildSlave("sreabhan", "tekcub")]

# to limit to two concurrent builds on a slave, use
#  c['slaves'] = [BuildSlave("bot1name", "bot1passwd", max_builds=2)]


# 'slavePortnum' defines the TCP port to listen on. This must match the value
# configured into the buildslaves (with their --master option)

c['slavePortnum'] = 9989

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes. Any class which implements IChangeSource can be
# put here: there are several in buildbot/changes/*.py to choose from.

#from buildbot.changes.pb import PBChangeSource
#c['change_source'] = PBChangeSource()
from buildbot.changes.gitpoller import GitPoller
c['change_source'] = []
c['change_source'].append(GitPoller('git@bitbucket.org:tferma/tferma.git',
                                    branch='dolfin-master',
                                    project='tferma/dolfin-master',
                                    pollinterval=2*60,
                                    workdir='/home/buildbot/gitpoller_workdir/tferma/dolfin-master'))
c['change_source'].append(GitPoller('git@bitbucket.org:tferma/tferma.git',
                                    branch='master',
                                    project='tferma/master',
                                    pollinterval=2*60,
                                    workdir='/home/buildbot/gitpoller_workdir/tferma/master'))

# For example, if you had CVSToys installed on your repository, and your
# CVSROOT/freshcfg file had an entry like this:
#pb = ConfigurationSet([
#    (None, None, None, PBService(userpass=('foo', 'bar'), port=4519)),
#    ])

# then you could use the following buildmaster Change Source to subscribe to
# the FreshCVS daemon and be notified on every commit:
#
#from buildbot.changes.freshcvs import FreshCVSSource
#fc_source = FreshCVSSource("cvs.example.com", 4519, "foo", "bar")
#c['change_source'] = fc_source

# or, use a PBChangeSource, and then have your repository's commit script run
# 'buildbot sendchange', or use contrib/svn_buildbot.py, or
# contrib/arch_buildbot.py :
#
#from buildbot.changes.pb import PBChangeSource
#c['change_source'] = PBChangeSource()

# If you wat to use SVNPoller, it might look something like
#  # Where to get source code changes
# from buildbot.changes.svnpoller import SVNPoller
# source_code_svn_url='https://svn.myproject.org/bluejay/trunk'
# svn_poller = SVNPoller(
#                    svnurl=source_code_svn_url,
#                    pollinterval=60*60, # seconds
#                    histmax=10,
#                    svnbin='/usr/bin/svn',
## )
# c['sources'] = [ svn_poller ]

####### SCHEDULERS

## configure the Schedulers

from buildbot.changes.filter import ChangeFilter
from buildbot.scheduler import Nightly
from buildbot.scheduler import Triggerable
from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.steps.trigger import Trigger
c['schedulers'] = []
#schedulers configures below definition of builders...

####### BUILDERS

# the 'builders' list defines the Builders. Each one is configured with a
# dictionary, using the following keys:
#  name (required): the name used to describe this builder
#  slavename (required): which slave to use (must appear in c['bots'])
#  builddir (required): which subdirectory to run the builder in
#  factory (required): a BuildFactory to define how the build is run
#  periodicBuildTime (optional): if set, force a build every N seconds

# buildbot/process/factory.py provides several BuildFactory classes you can
# start with, which implement build processes for common targets (GNU
# autoconf projects, CPAN perl modules, etc). The factory.BuildFactory is the
# base class, and is configured with a series of BuildSteps. When the build
# is run, the appropriate buildslave is told to execute each Step in turn.

# the first BuildStep is typically responsible for obtaining a copy of the
# sources. There are source-obtaining Steps in buildbot/steps/source.py for
# CVS, SVN, and others.

from buildbot.steps.source import Git, Bzr
from buildbot.process import factory
from buildbot.config import BuilderConfig
from buildbot.steps.shell import ShellCommand, SetProperty
from buildbot.process.properties import Property, Properties, PropertiesMixin
from buildbot.steps.python_twisted import Trial
from buildbot.interfaces import IRenderable
from zope.interface import implements
import functools

#############################################################################################################
def join_envs(*args, **kwargs):
        l_base_env = kwargs.get('base_env')
        if l_base_env is None: l_base_env = {}

        keys = set().union(*(list(args)+[l_base_env]))

        joinedenv = {k: ':'.join([path for env in args for path in env.get(k,'').split(':') \
                                  if not path=='' and not path in l_base_env.get(k,'').split(':')]) for k in keys}
        fullenv   = {k: ':'.join([path for env in [joinedenv, l_base_env] for path in env.get(k,'').split(':') \
                                  if not path=='']) for k in keys}

        return fullenv
#############################################################################################################

#############################################################################################################
class DetermineEnvProperty(object):
    implements(IRenderable)
    def getRenderingFor(self, props):
        envs = []
        base_env = {}
        if props.hasProperty('tferma_env'): envs.append(props['tferma_env'])
        if props.hasProperty('fenics_env'): envs.append(props['fenics_env'])
        if props.hasProperty('petsc_env'):  envs.append(props['petsc_env'])
        if props.hasProperty('spud_env'):   envs.append(props['spud_env'])
        if props.hasProperty('base_env'):   base_env = props['base_env']
        env = join_envs(*envs, **{'base_env': base_env})
        return env
#############################################################################################################

#############################################################################################################
def set_env_property(rc, stdout, stderr, env_name='env'):
    ''' Function used as the extract_fn function for SetProperty class
        This takes the output from env command and creates a dictionary of 
        the environment, the result of which is stored in a property names
        env'''
    if not rc:
        env_list = [ l.strip() for l in stdout.split('\n') ]
        env_dict={ l.split('=',1)[0]:l.split('=',1)[1] for l in 
                      env_list if len(l.split('=',1))==2}
        return {env_name:env_dict}
#############################################################################################################

#############################################################################################################
def get_base_env():
    
  env = {}
  env['LD_LIBRARY_PATH'] = ':'.join([ \
                         '/usr/local/lib',
                         '/usr/lib',
                         ])
  env['PATH'] = ':'.join([ \
                         '/bin',
                         '/usr/bin',
                         '/usr/local/bin',
                         ])

  return env
#############################################################################################################

#############################################################################################################
def get_spud_env(slavename, spudbuildername=None):
    
  env = {}
  if spudbuildername is not None:
    directory              = '/'.join([slavename, spudbuildername])
    spud_dir               = '/home/buildbot/spud-install/'+directory
    env['PYTHONPATH']      = spud_dir+'/lib/python2.7/site-packages'
    env['PATH']            = spud_dir+'/bin'
    env['LD_LIBRARY_PATH'] = spud_dir+'/lib'
    env['SPUD_DIR']        = spud_dir

  return env
#############################################################################################################

#############################################################################################################
def get_petsc_env(slavename, petscbuildername=None, petscversion=None, debug=False):

  petsc_dir = "petsc_dir_not_set"
  petscarch = "petsc_arch_not_set"
  if petscbuildername is not None:
    petsc_dir = "/home/buildbot/slaves/"+slavename+"/"+petscbuildername+"/build"
    petsc_arch = "petsc-arch"
  elif petscversion is not None:
    petsc_dir = "/usr/local/tferma/petsc"
    petsc_arch = "maint-"+petscversion
    if debug:
      petsc_arch = petsc_arch+'-debug'
    else:
      petsc_arch = petsc_arch+'-opt'

  env = {}
  env['PATH'] = petsc_dir+'/'+petsc_arch+'/bin'
  env['LD_LIBRARY_PATH'] = petsc_dir+'/'+petsc_arch+'/lib'
  env['PYTHONPATH'] = petsc_dir+'/'+petsc_arch+'/lib/python2.7/site-packages'
  env['PETSC_ARCH'] = petsc_arch
  env['PETSC_DIR'] = petsc_dir
  env['METIS_LIBRARY'] = env["PETSC_DIR"]+"/"+env["PETSC_ARCH"]+"/lib/libmetis.so"
  env['PARMETIS_LIBRARY'] = env["PETSC_DIR"]+"/"+env["PETSC_ARCH"]+"/lib/libparmetis.so"

  return env
#############################################################################################################

#############################################################################################################
def get_fenics_env(slavename, fenicsbuildername):
    
  directory = '/'.join([slavename, fenicsbuildername])
  env = {}
  env['PYTHONPATH'] = ':'.join([ \
                         '/home/buildbot/fenics-install/'+directory+'/lib/python2.7/site-packages',  \
                         '/home/buildbot/fenics-install/'+directory+'/lib/python2.7/dist-packages',  \
                         ])
  env['LD_LIBRARY_PATH'] = '/home/buildbot/fenics-install/'+directory+'/lib'
  env['PATH'] = '/home/buildbot/fenics-install/'+directory+'/bin'
  env['PKG_CONFIG_PATH'] = '/home/buildbot/fenics-install/'+directory+'/lib/pkgconfig'

  return env
#############################################################################################################

#############################################################################################################
def get_tferma_env(slavename, tfermabuildername):
    
  directory = '/'.join([slavename, tfermabuildername])
  env = {}
  env['PYTHONPATH'] = ':'.join([ \
                         '/home/buildbot/tferma-install/'+directory+'/lib/python2.7/dist-packages', \
                         '/home/buildbot/tferma-install/'+directory+'/lib/python2.7/site-packages', \
                         ])
  env['PATH'] = '/home/buildbot/tferma-install/'+directory+'/bin'
  env['TF_CMAKE_PATH'] = '/home/buildbot/tferma-install/'+directory+'/share/terraferma/cpp'
  env['BUCKETTOOLS_DIR'] = '/home/buildbot/tferma-install/'+directory
  env['CMAKE_MODULE_PATH'] = '/home/buildbot/tferma-install/'+directory+'/share/buckettools/cmake/modules'
  env['DIAMOND_CONFIG_PATH'] = '/home/buildbot/tferma-install/'+directory+'/share/buckettools/diamond'

  return env
#############################################################################################################

#############################################################################################################
from buildbot.status.builder import SUCCESS, WARNINGS, FAILURE, SKIPPED
class TFTestHarness(ShellCommand):
  def evaluateCommand(self, cmd):
    if cmd.rc != 0: return FAILURE
    self.warnOnWarnings = True
    passcount = -1
    failcount = -1
    counts = cmd.logs['stdio'].getText().strip().split('\n')[-19:]
    for count in counts:
      if count.strip().startswith("Passes:"):
        passcount = int(count.split()[-1])
      if count.strip().startswith("Failures:"):
        failcount = int(count.split()[-1])
        print "Line failing is: ", count

    # counts haven't been set (something went wrong above) or failcount is positive
    if failcount != 0 or passcount < 0: return FAILURE
    # passcount is positive and there were no failures
    if passcount > 0 and failcount==0: return SUCCESS
    # presumably passcount was 0?...
    return SKIPPED
#############################################################################################################

#############################################################################################################
def mk_tferma_builder(repo, slavename, tfermabuildername, 
                      fenicsbuildername, petscbuildername=None, petscversion=None, spudbuildername=None,
                      pretriggers=None, posttriggers=None, 
                      test=False, mediumtest=False, 
                      verbose=False, debug=False):

  base_env = get_base_env()
  spud_env = get_spud_env(slavename, spudbuildername)
  petsc_env = get_petsc_env(slavename, \
                      petscbuildername=petscbuildername, \
                      petscversion=petscversion, \
                      debug=debug)
  fenics_env = get_fenics_env(slavename, fenicsbuildername)
  tferma_env = get_tferma_env(slavename, tfermabuildername)
  env = join_envs(tferma_env, fenics_env, petsc_env, spud_env, base_env)

  verbosity = []
  if verbose: verbosity = ["VERBOSE=1"]

  if debug:
    build_type = 'Debug'
  else:
    build_type = 'RelWithDebInfo'

  fenicsdirectory = '/'.join([slavename, fenicsbuildername])
  fenicsinstalldirectory = '/home/buildbot/fenics-install/'+fenicsdirectory

  directory = '/'.join([slavename, tfermabuildername])
  installdirectory = '/home/buildbot/tferma-install/'+directory

  configure_options = [
     "-DCMAKE_BUILD_TYPE="+build_type, 
     "-DCMAKE_INSTALL_PREFIX="+installdirectory,
     ]

  cpack_options = [
     "-G", "DEB", 
     "-D", "CPACK_INSTALL_PREFIX=/tmp/install1", 
     "-D", "CPACK_INSTALL_CMAKE_PROJECTS=.;terraferma;ALL;/", 
     "-D", "CPACK_PACKAGE_FILE_NAME=terraferma-0.1-Linux", 
     "-D", "CPACK_PACKAGE_NAME=terraferma", 
     "-D", "CPACK_PACKAGE_DESCRIPTION=terraferma package", 
     "-D", "CPACK_PACKAGE_DESCRIPTION_SUMMARY=terraferma package", 
     "-D", "CPACK_PACKAGE_VERSION=0.1", 
     "-D", "CPACK_CMAKE_GENERATOR=Unix Makefiles", 
     "-D", "CPACK_PACKAGE_CONTACT=Cian Wilson <cwilson@ldeo.columbia.edu>", 
     "-D", "CPACK_SET_DESTDIR=ON"
     ]

  f = factory.BuildFactory()
  #if pretriggers is not None:
  #  f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  #f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  #f.addStep(ShellCommand(command=["mkdir", "-p", "build"], workdir="build", haltOnFailure=True, description="setup"))
  f.addStep(SetProperty(command="bash -c env",
              extract_fn=functools.partial(set_env_property, env_name='fenics_env'),
              workdir=fenicsinstalldirectory+"/share/dolfin",
              env={'BASH_ENV':'dolfin.conf' }))
  #f.addStep(ShellCommand(command=["cmake"]+configure_options+["../."], workdir="build/build", env=env, haltOnFailure=True, description="cmake"))
  #f.addStep(ShellCommand(command=["make"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="make"))
  #f.addStep(ShellCommand(command=["make", "install"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="install"))
  #if posttriggers is not None:
  #  f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  f.addStep(SetProperty(command="bash -c env",
              extract_fn=functools.partial(set_env_property, env_name='tferma_env'),
              workdir=installdirectory+"/share/terraferma",
              env={'BASH_ENV':'terraferma.conf' }))
  f.addStep(ShellCommand(command=["which", "dolfin-convert"], workdir="build/build", env=DetermineEnvProperty(), haltOnFailure=True, description="type"))
  if test: 
    f.addStep(TFTestHarness(command=["make", "test"]+verbosity, workdir="build/build", env=DetermineEnvProperty(), haltOnFailure=True, description="test"))
  #if mediumtest: 
  #  f.addStep(TFTestHarness(command=["make", "mediumtest"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="mediumtest", timeout=10000))
  #f.addStep(ShellCommand(command=["cpack"]+cpack_options, workdir="build/build", env=env, haltOnFailure=True, description="package"))
  
  b = BuilderConfig(name = tfermabuildername, slavename = slavename, builddir = tfermabuildername,
                    factory = f, category = "tferma", 
                    properties={'petsc_env': petsc_env, 'spud_env': spud_env, 'base_env': base_env})

  return b
#############################################################################################################

##############################################################################################################
#def mk_tferma_builder(repo, slavename, tfermabuildername, 
#                      fenicsbuildername, petscbuildername=None, petscversion=None, spudbuildername=None,
#                      pretriggers=None, posttriggers=None, 
#                      test=False, mediumtest=False, 
#                      verbose=False, debug=False):
#
#  base_env = get_base_env()
#  spud_env = get_spud_env(slavename, spudbuildername)
#  petsc_env = get_petsc_env(slavename, \
#                      petscbuildername=petscbuildername, \
#                      petscversion=petscversion, \
#                      debug=debug)
#  fenics_env = get_fenics_env(slavename, fenicsbuildername)
#
#  verbosity = []
#  if verbose: verbosity = ["VERBOSE=1"]
#
#  if debug:
#    build_type = 'Debug'
#  else:
#    build_type = 'RelWithDebInfo'
#
#  fenicsdirectory = '/'.join([slavename, fenicsbuildername])
#  fenicsinstalldirectory = '/home/buildbot/fenics-install/'+fenicsdirectory
#
#  directory = '/'.join([slavename, tfermabuildername])
#  installdirectory = '/home/buildbot/tferma-install/'+directory
#
#  configure_options = [
#     "-DCMAKE_BUILD_TYPE="+build_type, 
#     "-DCMAKE_INSTALL_PREFIX="+installdirectory,
#     ]
#
#  cpack_options = [
#     "-G", "DEB", 
#     "-D", "CPACK_INSTALL_PREFIX=/tmp/install1", 
#     "-D", "CPACK_INSTALL_CMAKE_PROJECTS=.;terraferma;ALL;/", 
#     "-D", "CPACK_PACKAGE_FILE_NAME=terraferma-0.1-Linux", 
#     "-D", "CPACK_PACKAGE_NAME=terraferma", 
#     "-D", "CPACK_PACKAGE_DESCRIPTION=terraferma package", 
#     "-D", "CPACK_PACKAGE_DESCRIPTION_SUMMARY=terraferma package", 
#     "-D", "CPACK_PACKAGE_VERSION=0.1", 
#     "-D", "CPACK_CMAKE_GENERATOR=Unix Makefiles", 
#     "-D", "CPACK_PACKAGE_CONTACT=Cian Wilson <cwilson@ldeo.columbia.edu>", 
#     "-D", "CPACK_SET_DESTDIR=ON"
#     ]
#
#  f = factory.BuildFactory()
#  #if pretriggers is not None:
#  #  f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
#  #f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
#  #f.addStep(ShellCommand(command=["mkdir", "-p", "build"], workdir="build", haltOnFailure=True, description="setup"))
#  #f.addStep(SetProperty(command="bash -c env",
#  #            extract_fn=functools.partial(set_env_property, env_name='fenics_env'),
#  #            workdir=fenicsinstalldirectory+"/share/dolfin",
#  #            env={'BASH_ENV':'dolfin.conf' }))
#  #f.addStep(ShellCommand(command=["cmake"]+configure_options+["../."], workdir="build/build", env=DetermineEnvProperty(), haltOnFailure=True, description="cmake"))
#  #f.addStep(ShellCommand(command=["make"]+verbosity, workdir="build/build", env=DetermineEnvProperty(), haltOnFailure=True, description="make"))
#  #f.addStep(ShellCommand(command=["make", "install"]+verbosity, workdir="build/build", env=DetermineEnvProperty(), haltOnFailure=True, description="install"))
#  #if posttriggers is not None:
#  #  f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
#  if test or mediumtest:
#    f.addStep(ShellCommand(command=["echo", Property('workdir')], workdir="build/build", env={},
#haltOnFailure=True, description="dolfin-convert"))
#    f.addStep(ShellCommand(command=["type", "dolfin-convert"], workdir="build/build", env=join_envs(fenics_env, base_env),
#haltOnFailure=True, description="dolfin-convert"))
#  #  f.addStep(SetProperty(command="bash -c env",
#  #              extract_fn=functools.partial(set_env_property, env_name='tferma_env'),
#  #              workdir=installdirectory+"/share/terraferma",
#  #              env={'BASH_ENV':'terraferma.conf' }))
#  #if test: 
#  #  f.addStep(TFTestHarness(command=["make", "test"]+verbosity, workdir="build/build", env=DetermineEnvProperty(), 
#  #                          haltOnFailure=True, description="test"))
#  #if mediumtest: 
#  #  f.addStep(TFTestHarness(command=["make", "mediumtest"]+verbosity, workdir="build/build", env=DetermineEnvProperty(), haltOnFailure=True, description="mediumtest", timeout=10000))
#  #f.addStep(ShellCommand(command=["cpack"]+cpack_options, workdir="build/build", env=base_env, haltOnFailure=True, description="package"))
#  
#  b = BuilderConfig(name = tfermabuildername, slavename = slavename, builddir = tfermabuildername,
#                    factory = f, category = "tferma", 
#                    properties={'petsc_env': petsc_env, 'spud_env': spud_env, 'base_env': base_env})
#
#  return b
##############################################################################################################

#############################################################################################################
def mk_tferma_benchmarks_builder(repo, slavename, benchmarksbuildername, tfermabuildername, 
                                 fenicsbuildername, petscbuildername=None, petscversion=None, spudbuildername=None,
                                 pretriggers=None, posttriggers=None, debug=False):

  base_env = get_base_env()
  spud_env = get_spud_env(slavename, spudbuildername)
  petsc_env = get_petsc_env(slavename, \
                      petscbuildername=petscbuildername, \
                      petscversion=petscversion, \
                      debug=debug)
  fenics_env = get_fenics_env(slavename, fenicsbuildername)
  tferma_env = get_tferma_env(slavename, tfermabuildername)
  env = join_envs(tferma_env, fenics_env, petsc_env, spud_env, base_env)

  directory = '/'.join([slavename, benchmarksbuildername])

  f = factory.BuildFactory()
  if pretriggers is not None:
    f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  f.addStep(TFTestHarness(command=["tfsimulationharness", "--test", "-l", "short", "-r", "--", "*.shml"], 
                          workdir="build", env=env,haltOnFailure=True, description="test",timeout=None))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  
  b = BuilderConfig(name = benchmarksbuildername, slavename = slavename, builddir = benchmarksbuildername,
                    factory = f, category = "benchmarks")

  return b
#############################################################################################################

#############################################################################################################
def mk_tferma_dorsal_builder(repo, slavename, dorsalbuildername,
                             pretriggers=None, posttriggers=None, debug=False):

  env = get_base_env()

  directory = '/'.join([slavename, dorsalbuildername])
  installdirectory = '/home/buildbot/dorsal-install/'+directory

  localconfig = "\"# Meta-project to build\n"+\
                "PROJECT=TerraFERMA\n"+\
                "# Where do you want the downloaded source files to go?\n"+\
                "DOWNLOAD_PATH=/home/buildbot/dorsal-download/"+directory+"\n"+\
                "# Where do you want the compiled software installed?\n"+\
                "INSTALL_PATH="+installdirectory+"\n"+\
                "# How many processes would you like to build using?\n"+\
                "PROCS=1\n"+\
                "# For TerraFERMA the two following variables should be set to false\n"+\
                "STABLE_BUILD=false\n"+\
                "USE_SNAPSHOTS=false\n\""

  f = factory.BuildFactory()
  if pretriggers is not None:
    f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  f.addStep(ShellCommand(command="echo "+localconfig+" > local.cfg", 
                          workdir="build", env=env,haltOnFailure=True, description="setup"))
  f.addStep(ShellCommand(command=["./dorsal.sh"], 
                          workdir="build", env=env,haltOnFailure=True, description="build"))
  f.addStep(SetProperty(command="bash -c env",
              extract_fn=set_env_property,
              workdir=installdirectory+"/share/terraferma",
              env={'BASH_ENV':'terraferma.conf' }))
  f.addStep(ShellCommand(command=["run_tftests"],
              workdir="build", env=Property('env'), description="test"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  
  b = BuilderConfig(name = dorsalbuildername, slavename = slavename, builddir = dorsalbuildername,
                    factory = f, category = "dorsal")

  return b
#############################################################################################################

#############################################################################################################
def mk_petsc_builder(repo, slavename, petscbuildername, posttriggers=None, debug=False):

  petsc_dir = "/home/buildbot/slaves/"+slavename+"/"+petscbuildername+"/build"
  petsc_arch = "petsc-arch"

  env = get_base_env()

  configure_options = [
     '--PETSC_DIR='+petsc_dir,
     '--PETSC_ARCH='+petsc_arch,
     '--with-clanguage=C++',
     '--with-shared-libraries=1',
     '--download-umfpack=1',
     '--download-hypre=1',
     '--download-ml=1',
     '--download-parmetis=1',
     '--download-metis=1',
     '--download-blacs=1',
     '--download-scalapack=1',
     '--download-mumps=1',
     ]

  if debug:
    configure_options += ['--with-debugging=1']
  else:
    configure_options += ['--with-debugging=0']

  f = factory.BuildFactory()
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  f.addStep(ShellCommand(command=["./configure"]+configure_options, workdir="build", haltOnFailure=True, description="configure"))
  f.addStep(ShellCommand(command=["make", "PETSC_DIR="+petsc_dir, "PETSC_ARCH="+petsc_arch, "all"], workdir="build", haltOnFailure=True, description="build"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  f.addStep(ShellCommand(command=["make", "PETSC_DIR="+petsc_dir, "PETSC_ARCH="+petsc_arch, "test"], workdir="build", haltOnFailure=True, description="test"))
  
  b = BuilderConfig(name = petscbuildername, slavename = slavename, builddir = petscbuildername,
                    factory = f, category = 'petsc')

  return b
#############################################################################################################

#############################################################################################################
def mk_fenics_ufc_builder(repo, slavename, fenicsbuildername, posttriggers=None, \
                          mergebranch=None, verbose=False, debug=False):

  env = get_base_env()

  verbosity = []
  if verbose: verbosity = ["VERBOSE=1"]

  if debug:
    build_type = 'Debug'
  else:
    build_type = 'RelWithDebInfo'

  directory = '/'.join([slavename, fenicsbuildername])

  f = factory.BuildFactory()
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  if mergebranch is not None:
    f.addStep(ShellCommand(command=["git", "fetch", mergebranch[0]+"/ufc.git", mergebranch[1]+":mergebranch/"+mergebranch[1]], 
                                    workdir="build", haltOnFailure=True, description="fetch"))
    f.addStep(ShellCommand(command=["git", "merge", "mergebranch/"+mergebranch[1]], workdir="build", haltOnFailure=True, description="merge"))
  f.addStep(ShellCommand(command=["mkdir", "-p", "build"], workdir="build", haltOnFailure=True, description="setup"))
  f.addStep(ShellCommand(command=["cmake", "-DCMAKE_BUILD_TYPE="+build_type, "-DCMAKE_INSTALL_PREFIX=/home/buildbot/fenics-install/"+directory, "../."], workdir="build/build", env=env, haltOnFailure=True, description="cmake"))
  f.addStep(ShellCommand(command=["make"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="make"))
  f.addStep(ShellCommand(command=["make", "install"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="install"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))

  b = BuilderConfig(name = fenicsbuildername+'-ufc', slavename = slavename, builddir = fenicsbuildername+'-ufc',
                    factory = f, category = 'ufc')

  return b
#############################################################################################################

#############################################################################################################
def mk_fenics_dolfin_builder(repo, slavename, fenicsbuildername, 
                             petscbuildername=None, petscversion=None, 
                             test=False, posttriggers=None, mergebranch=None,
                             verbose=False, debug=False):

  base_env = get_base_env()
  petsc_env = get_petsc_env(slavename, \
                      petscbuildername=petscbuildername, \
                      petscversion=petscversion, \
                      debug=debug)
  fenics_env = get_fenics_env(slavename, fenicsbuildername)
  env = join_envs(fenics_env, petsc_env, base_env)

  verbosity = []
  if verbose: verbosity = ["VERBOSE=1"]

  if debug:
    build_type = 'Debug'
  else:
    build_type = 'RelWithDebInfo'

  directory = '/'.join([slavename, fenicsbuildername])
  configure_options = [
     "-DCMAKE_BUILD_TYPE="+build_type, 
     "-DCMAKE_INSTALL_PREFIX=/home/buildbot/fenics-install/"+directory, 
     "-DDOLFIN_ENABLE_TRILINOS:BOOL=OFF", 
     "-DDOLFIN_ENABLE_SLEPC:BOOL=OFF", 
     "-DAMD_INCLUDE_DIRS="+env["PETSC_DIR"]+"/"+env["PETSC_ARCH"]+"/include", 
     "-DAMD_LIBRARIES="+env["PETSC_DIR"]+"/"+env["PETSC_ARCH"]+"/lib/libamd.a", 
     "-DMETIS_LIBRARY="+env["METIS_LIBRARY"], 
     "-DPARMETIS_INCLUDE_DIRS="+env["PETSC_DIR"]+"/"+env["PETSC_ARCH"]+"/include", 
     "-DPARMETIS_LIBRARY="+env["PARMETIS_LIBRARY"], 
     "-DUMFPACK_INCLUDE_DIRS="+env["PETSC_DIR"]+"/"+env["PETSC_ARCH"]+"/include", 
     "-DUMFPACK_LIBRARY="+env["PETSC_DIR"]+"/"+env["PETSC_ARCH"]+"/lib/libumfpack.a",
     #"-DCGAL_DIR=/usr/local/cgal/4.1/lib/CGAL",
     "-DDOLFIN_ENABLE_CGAL:BOOL=OFF",
     "-DDOLFIN_ENABLE_TESTING:BOOL=ON",
     ]

  f = factory.BuildFactory()
  f.addStep(Trigger(schedulerNames=[fenicsbuildername+'-instant'], 
                    waitForFinish=True, alwaysUseLatest=True))
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  if mergebranch is not None:
    f.addStep(ShellCommand(command=["git", "fetch", mergebranch[0]+"/dolfin.git", mergebranch[1]+":mergebranch/"+mergebranch[1]], 
                                    workdir="build", haltOnFailure=True, description="fetch"))
    f.addStep(ShellCommand(command=["git", "merge", "mergebranch/"+mergebranch[1]], workdir="build", haltOnFailure=True, description="merge"))
  f.addStep(ShellCommand(command=["mkdir", "-p", "build"], workdir="build", haltOnFailure=True, description="setup"))
  f.addStep(ShellCommand(command=["cmake"]+configure_options+["../."], workdir="build/build", env=env, haltOnFailure=True, description="cmake"))
  f.addStep(ShellCommand(command=["make"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="make"))
  f.addStep(ShellCommand(command=["make", "install"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="install"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  f.addStep(ShellCommand(command=["make", "test"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="make test"))
  f.addStep(ShellCommand(command=["make", "demo"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="make demo"))
  f.addStep(ShellCommand(command=["make", "bench"]+verbosity, workdir="build/build", env=env, haltOnFailure=True, description="make bench"))
  if test:
    f.addStep(ShellCommand(command=["make", "run_unittests"]+verbosity, workdir="build/build", env=env, haltOnFailure=False, description="make run_unittests"))
    f.addStep(ShellCommand(command=["make", "run_regressiontests"]+verbosity, workdir="build/build", env=env, haltOnFailure=False, description="make run_regressiontests"))
    f.addStep(ShellCommand(command=["make", "run_systemtests"]+verbosity, workdir="build/build", env=env, haltOnFailure=False, description="make run_systemtests"))

  b = BuilderConfig(name = fenicsbuildername+'-dolfin', slavename = slavename, builddir = fenicsbuildername+'-dolfin',
                    factory = f, category = 'dolfin')

  return b
#############################################################################################################

#############################################################################################################
def mk_fenics_python_builder(repo, slavename, fenicsbuildername, project, test=False, 
                             pretriggers=None, posttriggers=None,
                             mergebranch=None, debug=False):

  env = get_base_env()
  fenics_env = get_fenics_env(slavename, fenicsbuildername)
  test_env = join_envs(fenics_env, env)

  directory = "/".join([slavename, fenicsbuildername])
  commands = ["python", "setup.py", "install", "--prefix=/home/buildbot/fenics-install/"+directory]
  if debug: commands.append("-O0")

  f = factory.BuildFactory()
  if pretriggers is not None:
    f.addStep(Trigger(schedulerNames=pretriggers, waitForFinish=True, alwaysUseLatest=True))
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  if mergebranch is not None:
    f.addStep(ShellCommand(command=["git", "fetch", mergebranch[0]+"/"+project+".git", mergebranch[1]+":mergebranch/"+mergebranch[1]], 
                                    workdir="build", haltOnFailure=True, description="fetch"))
    f.addStep(ShellCommand(command=["git", "merge", "mergebranch/"+mergebranch[1]], workdir="build", haltOnFailure=True, description="merge"))
  f.addStep(ShellCommand(command=commands, workdir="build", env=env, haltOnFailure=True, description="install"))
  if test:
    f.addStep(ShellCommand(command=["python", "test.py"], workdir="build/test", env=test_env, haltOnFailure=True, description="test"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  
  b = BuilderConfig(name = fenicsbuildername+"-"+project, slavename = slavename, 
                    builddir = fenicsbuildername+"-"+project, factory = f,
                    category = project)

  return b
#############################################################################################################

#############################################################################################################
def mk_fenics_instant_builder(repo, slavename, fenicsbuildername, test=False, 
                              posttriggers=None, mergebranch=None, debug=False):

  env = get_base_env()
  fenics_env = get_fenics_env(slavename, fenicsbuildername)
  test_env = join_envs(fenics_env, env)

  directory = "/".join([slavename, fenicsbuildername])
  commands = ["python", "setup.py", "install", "--prefix=/home/buildbot/fenics-install/"+directory]
  if debug: commands.append("-O0")

  f = factory.BuildFactory()
  f.addStep(Trigger(schedulerNames=[fenicsbuildername+'-ufl', 
                                    fenicsbuildername+'-ffc'],
                    waitForFinish=True, alwaysUseLatest=True))
  f.addStep(Git(repourl=repo[0], branch=repo[1], mode='clobber', haltOnFailure=True))
  if mergebranch is not None:
    f.addStep(ShellCommand(command=["git", "fetch", mergebranch[0]+"/instant.git", mergebranch[1]+":mergebranch/"+mergebranch[1]], 
                                    workdir="build", haltOnFailure=True, description="fetch"))
    f.addStep(ShellCommand(command=["git", "merge", "mergebranch/"+mergebranch[1]], workdir="build", haltOnFailure=True, description="merge"))
  f.addStep(ShellCommand(command=commands, workdir="build", env=env, haltOnFailure=True, description="install"))
  if test:
    f.addStep(ShellCommand(command=["python", "run_tests.py"], workdir="build/test", env=test_env, haltOnFailure=True, description="run_tests"))
  if posttriggers is not None:
    f.addStep(Trigger(schedulerNames=posttriggers, waitForFinish=False, alwaysUseLatest=True))
  
  b = BuilderConfig(name = fenicsbuildername+"-instant", slavename = slavename, builddir = fenicsbuildername+"-instant",
                    factory = f, category = 'instant')

  return b
#############################################################################################################

#############################################################################################################
def mk_spud_builder(repourl, slavename, spudbuildername, debug=False):

  env = get_base_env()

  directory = '/home/buildbot/spud-install/'+slavename+'/'+spudbuildername
  if debug:
    commands = ["./configure", "--enable-debugging", "--prefix="+directory]
  else:
    commands = ["./configure", "--prefix="+directory]


  f = factory.BuildFactory()
  f.addStep(Bzr(repourl=repourl))
  f.addStep(ShellCommand(command=commands, workdir="build", env=env, haltOnFailure=True, description="configure"))
  f.addStep(ShellCommand(command=["make"], workdir="build", env=env, haltOnFailure=True, description="make"))
  f.addStep(ShellCommand(command=["make", "install"], workdir="build", env=env, haltOnFailure=True, description="install"))

  b = BuilderConfig(name = spudbuildername, slavename = slavename, builddir = spudbuildername,
                    factory = f, category = "spud")

  return b
#############################################################################################################

#############################################################################################################
def mk_fenics_builders(repos, slavename, fenicsbuildername, test=False,
                       petscbuildername=None, petscversion=None, posttriggers=None, mergebranch=None,
                       verbose=False, debug=False):
   
  builders = []
  schedulers = []
  
  builders.append(mk_fenics_python_builder(repos['ufl'], slavename, fenicsbuildername, "ufl", test=test, 
                                           mergebranch=mergebranch, debug=debug))
  schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

  builders.append(mk_fenics_instant_builder(repos['instant'], slavename, fenicsbuildername, test=test,
                                           mergebranch=mergebranch, debug=debug))
  schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

  builders.append(mk_fenics_python_builder(repos['fiat'], slavename, fenicsbuildername, "fiat", test=test, 
                                           mergebranch=mergebranch, debug=debug))
  schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

  builders.append(mk_fenics_python_builder(repos['ffc'], slavename, fenicsbuildername, "ffc", test=test, pretriggers=[fenicsbuildername+'-fiat', fenicsbuildername+'-ufc'],
                                           mergebranch=mergebranch, debug=debug))
  schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

  builders.append(mk_fenics_ufc_builder(repos['ufc'], slavename, fenicsbuildername,
                                        verbose=verbose, mergebranch=mergebranch, debug=debug))
  schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

  dolfinbuilder = mk_fenics_dolfin_builder(repos['dolfin'], slavename, fenicsbuildername, petscbuildername=petscbuildername, \
                                           petscversion=petscversion, test=test, posttriggers=posttriggers, \
                                           mergebranch=mergebranch, verbose=verbose, debug=debug)
  
  return dolfinbuilder, builders, schedulers
#############################################################################################################

builders = []
schedulers = []

# spud builder
builders.append(mk_spud_builder('lp:spud', 'sreabhan', 'SPuD-spud'))

# PETSc-tferma_petsc_maint builder
petscrepo = ['git@bitbucket.org:tferma/petsc.git', 'maint']
builders.append(mk_petsc_builder(petscrepo, 'sreabhan', 'PETSc-tferma_petsc_maint', debug=True))

# PETSc-petsc_petsc_maint builder
petscrepo = ['git@bitbucket.org:petsc/petsc.git', 'maint']
builders.append(mk_petsc_builder(petscrepo, 'sreabhan', 'PETSc-petsc_petsc_maint', debug=True))

# FEniCS-tferma_fenics_master builders
repos = {
          'ufl'     : ['git@bitbucket.org:tferma/ufl.git',     'master'],
          'instant' : ['git@bitbucket.org:tferma/instant.git', 'master'],
          'fiat'    : ['git@bitbucket.org:tferma/fiat.git',    'master'],
          'ffc'     : ['git@bitbucket.org:tferma/ffc.git',     'master'],
          'ufc'     : ['git@bitbucket.org:tferma/ufc.git',     'master'],
          'dolfin'  : ['git@bitbucket.org:tferma/dolfin.git',  'master'],
        }
dolfinbuilder, tmpbuilders, tmpschedulers = mk_fenics_builders(repos, 'sreabhan', 'FEniCS-tferma_fenics_master', 
                                                               petscbuildername='PETSc-petsc_petsc_maint', debug=True)
builders = builders + tmpbuilders
schedulers = schedulers + tmpschedulers
builders.append(dolfinbuilder)
#schedulers.append(Nightly(name=dolfinbuilder.name, branch=None, builderNames=[dolfinbuilder.name], hour=2))

# TerraFERMA-tferma_tferma_dolfinmaster builder
tfermarepo = ['git@bitbucket.org:tferma/tferma.git', 'dolfin-master']
builders.append(mk_tferma_builder(tfermarepo, 'sreabhan', 'TerraFERMA-tferma_tferma_dolfinmaster', 
                      'FEniCS-tferma_fenics_master', petscbuildername='PETSc-petsc_petsc_maint', spudbuildername='SPuD-spud',
                      test=True, mediumtest=False, debug=True, verbose=False))
schedulers.append(SingleBranchScheduler(
                  name = builders[-1].name,
                  builderNames = [builders[-1].name],
                  change_filter = ChangeFilter(
                          project = 'tferma/dolfin-master',
                          branch  = 'dolfin-master'
                  )))

# PETSc-petsc_petsc_master builder
petscrepo = ['git@bitbucket.org:petsc/petsc.git', 'master']
builders.append(mk_petsc_builder(petscrepo, 'sreabhan', 'PETSc-petsc_petsc_master', 
                posttriggers=['FEniCS-fenics_fenics_master-dolfin'], debug=True))
schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], hour=2))

# fenics-project_fenics_master builder
repos = {
          'ufl'     : ['git@bitbucket.org:fenics-project/ufl.git',     'master'],
          'instant' : ['git@bitbucket.org:fenics-project/instant.git', 'master'],
          'fiat'    : ['git@bitbucket.org:fenics-project/fiat.git',    'master'],
          'ffc'     : ['git@bitbucket.org:fenics-project/ffc.git',     'master'],
          'ufc'     : ['git@bitbucket.org:fenics-project/ufc.git',     'master'],
          'dolfin'  : ['git@bitbucket.org:fenics-project/dolfin.git',  'master'],
        }
dolfinbuilder, tmpbuilders, tmpschedulers = mk_fenics_builders(repos, 'sreabhan', 'FEniCS-fenics_fenics_master', 
                                                               petscbuildername='PETSc-petsc_petsc_master', debug=True,
                                                               posttriggers=['TerraFERMA-tferma_tferma_dolfinmaster-testupdate'])
builders = builders + tmpbuilders
schedulers = schedulers + tmpschedulers
builders.append(dolfinbuilder)
schedulers.append(Triggerable(name=dolfinbuilder.name, builderNames=[dolfinbuilder.name]))


# TerraFERMA-tferma_tferma_dolfinmaster_test-update builder (built against nightly build of fenics_fenics_master)
tfermarepo = ['git@bitbucket.org:tferma/tferma.git', 'dolfin-master']
builders.append(mk_tferma_builder(tfermarepo, 'sreabhan', 'TerraFERMA-tferma_tferma_dolfinmaster-testupdate', 
                      'FEniCS-fenics_fenics_master', petscbuildername='PETSc-petsc_petsc_master', spudbuildername='SPuD-spud',
                      test=True, mediumtest=False, debug=True))
schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))


# PETSc-petsc_petsc_next builder
petscrepo = ['git@bitbucket.org:petsc/petsc.git', 'next']
builders.append(mk_petsc_builder(petscrepo, 'sreabhan', 'PETSc-petsc_petsc_next', 
                posttriggers=['FEniCS-fenics_fenics_next-dolfin'], debug=True))
schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], hour=2))

# fenics-project_fenics_next builder
repos = {
          'ufl'     : ['git@bitbucket.org:fenics-project/ufl.git',     'next'],
          'instant' : ['git@bitbucket.org:fenics-project/instant.git', 'next'],
          'fiat'    : ['git@bitbucket.org:fenics-project/fiat.git',    'next'],
          'ffc'     : ['git@bitbucket.org:fenics-project/ffc.git',     'next'],
          'ufc'     : ['git@bitbucket.org:fenics-project/ufc.git',     'next'],
          'dolfin'  : ['git@bitbucket.org:fenics-project/dolfin.git',  'next'],
        }
dolfinbuilder, tmpbuilders, tmpschedulers = mk_fenics_builders(repos, 'sreabhan', 'FEniCS-fenics_fenics_next', 
                                                               petscbuildername='PETSc-petsc_petsc_next', debug=True,
                                                               posttriggers=['TerraFERMA-tferma_tferma_dolfinmaster-testnextupdate'])
builders = builders + tmpbuilders
schedulers = schedulers + tmpschedulers
builders.append(dolfinbuilder)
schedulers.append(Triggerable(name=dolfinbuilder.name, builderNames=[dolfinbuilder.name]))


# TerraFERMA-tferma_tferma_dolfinmaster_testnextupdate builder (built against nightly build of fenics_fenics_nextupdate)
tfermarepo = ['git@bitbucket.org:tferma/tferma.git', 'dolfin-master']
builders.append(mk_tferma_builder(tfermarepo, 'sreabhan', 'TerraFERMA-tferma_tferma_dolfinmaster-testnextupdate', 
                      'FEniCS-fenics_fenics_next', petscbuildername='PETSc-petsc_petsc_next', spudbuildername='SPuD-spud',
                      test=True, mediumtest=False, debug=True))
schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))


# FEniCS-tferma_fenics_tferma-master builder
repos = {
          'ufl'     : ['git@bitbucket.org:tferma/ufl.git',     'tferma-master'],
          'instant' : ['git@bitbucket.org:tferma/instant.git', 'tferma-master'],
          'fiat'    : ['git@bitbucket.org:tferma/fiat.git',    'tferma-master'],
          'ffc'     : ['git@bitbucket.org:tferma/ffc.git',     'tferma-master'],
          'ufc'     : ['git@bitbucket.org:tferma/ufc.git',     'tferma-master'],
          'dolfin'  : ['git@bitbucket.org:tferma/dolfin.git',  'tferma-master'],
        }
dolfinbuilder, tmpbuilders, tmpschedulers = mk_fenics_builders(repos, 'sreabhan', 'FEniCS-tferma_fenics_tfermamaster', 
                                                               petscbuildername='PETSc-petsc_petsc_maint', debug=True)
builders = builders + tmpbuilders
schedulers = schedulers + tmpschedulers
builders.append(dolfinbuilder)

# TerraFERMA-tferma_tferma_master builder
tfermarepo = ['git@bitbucket.org:tferma/tferma.git', 'master']
builders.append(mk_tferma_builder(tfermarepo, 'sreabhan', 'TerraFERMA-tferma_tferma_master', 
                      'FEniCS-tferma_fenics_tfermamaster', petscbuildername='PETSc-petsc_petsc_maint', spudbuildername='SPuD-spud',
                      test=True, mediumtest=False, debug=True))
                      #test=True, mediumtest=False, debug=True, posttriggers=["Benchmarks-tferma_benchmarks_master"]))
schedulers.append(SingleBranchScheduler(
                  name = builders[-1].name,
                  builderNames = [builders[-1].name],
                  change_filter = ChangeFilter(
                          project = 'tferma/master',
                          branch  = 'master'
                  )))

# Benchmarks-tferma_benchmarks_master builder
benchmarksrepo = ['git@bitbucket.org:tferma/benchmarks.git', 'master']
builders.append(mk_tferma_benchmarks_builder(benchmarksrepo, 'sreabhan', 'Benchmarks-tferma_benchmarks_master',
                'TerraFERMA-tferma_tferma_master', 'FEniCS-tferma_fenics_tfermamaster', petscbuildername='PETSc-petsc_petsc_maint',
                spudbuildername='Spud-spud', debug=True))
#schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

# FEniCS-tferma_fenics_tfermamaster_merge builder
repos = {
          'ufl'     : ['git@bitbucket.org:tferma/ufl.git',     'tferma-master'],
          'instant' : ['git@bitbucket.org:tferma/instant.git', 'tferma-master'],
          'fiat'    : ['git@bitbucket.org:tferma/fiat.git',    'tferma-master'],
          'ffc'     : ['git@bitbucket.org:tferma/ffc.git',     'tferma-master'],
          'ufc'     : ['git@bitbucket.org:tferma/ufc.git',     'tferma-master'],
          'dolfin'  : ['git@bitbucket.org:tferma/dolfin.git',  'tferma-master'],
        }
dolfinbuilder, tmpbuilders, tmpschedulers = mk_fenics_builders(repos, 'sreabhan', 'FEniCS-tferma_fenics_tfermamaster-merge', 
                                                               petscbuildername='PETSc-petsc_petsc_maint', 
                                                               mergebranch=['git@bitbucket.org:fenics-project', 'master'], 
                                                               debug=True, posttriggers=['TerraFERMA-tferma_tferma_master-testmerge'])
builders = builders + tmpbuilders
schedulers = schedulers + tmpschedulers
builders.append(dolfinbuilder)
schedulers.append(Nightly(name=dolfinbuilder.name, branch=None, builderNames=[dolfinbuilder.name], hour=2))


# TerraFERMA-tferma_tferma_master-testmerge builder
tfermarepo = ['git@bitbucket.org:tferma/tferma.git', 'master']
builders.append(mk_tferma_builder(tfermarepo, 'sreabhan', 'TerraFERMA-tferma_tferma_master-testmerge', 
                      'FEniCS-tferma_fenics_tfermamaster-merge', petscbuildername='PETSc-petsc_petsc_maint', spudbuildername='SPuD-spud',
                      test=True, mediumtest=False, debug=True))
                      #test=True, mediumtest=False, debug=True, posttriggers=['Benchmarks-tferma_benchmarks_master-testmerge']))
schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

# Benchmarks-tferma_benchmarks_master-testmerge builder
benchmarksrepo = ['git@bitbucket.org:tferma/benchmarks.git', 'master']
builders.append(mk_tferma_benchmarks_builder(benchmarksrepo, 'sreabhan', 'Benchmarks-tferma_benchmarks_master-testmerge',
                'TerraFERMA-tferma_tferma_master-testmerge', 'FEniCS-tferma_fenics_tfermamaster-merge', petscbuildername='PETSc-petsc_petsc_maint',
                spudbuildername='Spud-spud', debug=True))
#schedulers.append(Triggerable(name=builders[-1].name, builderNames=[builders[-1].name]))

dorsalrepo = ['git@bitbucket.org:tferma/dorsal.git', 'tferma-master']
builders.append(mk_tferma_dorsal_builder(dorsalrepo, 'sreabhan', 'Dorsal-tferma_dorsal_tfermamaster'))
schedulers.append(Nightly(name=builders[-1].name, branch=None, builderNames=[builders[-1].name], dayOfWeek=7, hour=0))

c['builders'] = builders
c['schedulers'] = schedulers

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

# Use allowForce=True (boolean, not a string. ie: not 'True') to allow
# Forcing Builds in the Web User Interface. The default is False.
# from buildbot.status import html
# c['status'].append(html.WebStatus(http_port=8010,allowForce=True))

from buildbot.status import html
from buildbot.status.web.authz import Authz
from buildbot.status.web.auth import BasicAuth
users = [('buildbot', 'tekcub')]
#authz = Authz(auth=BasicAuth(users),
#              forceBuild='auth',
#              stopBuild='auth',
#              stopAllBuilds='auth',
#              cancelPendingBuild='auth'
#             )
authz = Authz(
              forceBuild=True,
              stopBuild=True,
              stopAllBuilds=True,
              cancelPendingBuild=True
             )
c['status'].append(html.WebStatus(http_port=8010, authz=authz))

from buildbot.status import mail
#c['status'].append(mail.MailNotifier(fromaddr="buildbot@sreabhan.ldeo.columbia.edu", mode="failing",
#                                     extraRecipients=["cwilson@ldeo.columbia.edu", "mspieg@ldeo.columbia.edu"],
#                                     sendToInterestedUsers=False))

# from buildbot.status import words
# c['status'].append(words.IRC(host="irc.example.com", nick="bb",
#                              channels=["#example"]))
#
# from buildbot.status import client
# c['status'].append(client.PBListener(9988))


####### DEBUGGING OPTIONS

# if you set 'debugPassword', then you can connect to the buildmaster with
# the diagnostic tool in contrib/debugclient.py . From this tool, you can
# manually force builds and inject changes, which may be useful for testing
# your buildmaster without actually committing changes to your repository (or
# before you have a functioning 'sources' set up). The debug tool uses the
# same port number as the slaves do: 'slavePortnum'.

#c['debugPassword'] = "debugpassword"

# if you set 'manhole', you can ssh into the buildmaster and get an
# interactive python shell, which may be useful for debugging buildbot
# internals. It is probably only useful for buildbot developers. You can also
# use an authorized_keys file, or plain telnet.
#from buildbot import manhole
#c['manhole'] = manhole.PasswordManhole("tcp:9999:interface=127.0.0.1",
#                                       "admin", "password")


####### PROJECT IDENTITY

# the 'projectName' string will be used to describe the project that this
# buildbot is working on. For example, it is used as the title of the
# waterfall HTML page. The 'projectURL' string will be used to provide a link
# from buildbot HTML pages to your project's home page.

c['projectName'] = "TerraFERMA"
c['projectURL'] = "https://bitbucket.org/tferma/tferma"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.Waterfall page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://sreabhan.ldeo.columbia.edu:8010/waterfall"
